<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>ButtonGridTool ‚Äì iPhone Wizard</title>
  <style>
    :root { --pad: 12px; --gap: 10px; --b:#2b6cff; }
    body { font-family:-apple-system,system-ui,Segoe UI,Roboto,Arial; margin:0; background:#f5f6f8; }
    header { background:#fff; border-bottom:1px solid #ddd; padding:10px 12px; position:sticky; top:0; z-index:10;
      display:flex; align-items:center; justify-content:space-between; gap:10px;}
    header h1 { font-size:16px; margin:0; }
    .hdrBtns{ display:flex; gap:10px; align-items:center; }
    a { text-decoration:none; }
    button, select, input[type="number"], input[type="range"] {
      font-size:16px; padding:10px 12px; border-radius:10px; border:1px solid #bbb; background:#fff;
    }
    button.primary{ background:var(--b); color:#fff; border-color:var(--b); }
    button.danger{ background:#ff3b30; color:#fff; border-color:#ff3b30; }
    button:disabled{ opacity:.5; }
    main{ padding:var(--pad); max-width:980px; margin:0 auto; }
    .card{ background:#fff; border:1px solid #ddd; border-radius:10px; padding:12px; margin:10px 0; }
    .row{ display:flex; flex-wrap:wrap; gap:var(--gap); align-items:center; }
    .pill{ display:inline-flex; gap:8px; align-items:center; padding:8px 10px; border:1px solid #ddd; border-radius:999px; }
    canvas{ width:100%; height:auto; border:1px solid #ddd; border-radius:10px; background:#000; touch-action:none; }
    .small{ color:#666; font-size:13px; line-height:1.35; }
    .split{ display:grid; grid-template-columns:1fr 1fr; gap:10px; }
    @media (max-width:720px){ .split{ grid-template-columns:1fr; } }
    .stepTitle{ font-weight:700; margin:0 0 8px 0; display:flex; align-items:center; justify-content:space-between; gap:10px;}
    .badge{ font-size:12px; padding:4px 8px; border-radius:999px; border:1px solid #ddd; color:#333; background:#fafafa;}
    .ok{ border-color:#7bd88f; background:#eaffef; }
    .warn{ border-color:#ffd37b; background:#fff5e6; }
    .muted{ color:#777; font-size:13px; }
    .toolbtn{ padding:10px 12px; }
    .hr{ height:1px; background:#eee; margin:10px 0; }

    /* modal */
    .modalBackdrop{ position:fixed; inset:0; background:rgba(0,0,0,.35); display:none; align-items:flex-end; justify-content:center; z-index:999; padding:12px; }
    .modal{ width:min(980px, 100%); background:#fff; border-radius:16px; border:1px solid #ddd; padding:12px; max-height:82vh; overflow:auto; }
    .modalHeader{ display:flex; align-items:center; justify-content:space-between; gap:10px; }
    .modalHeader h2{ margin:0; font-size:16px; }
    .mono{ font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; }
    .copyRow{ display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
    .copyBox{ flex:1; min-width:220px; padding:10px 12px; border:1px solid #ddd; border-radius:12px; background:#fafafa; }
  </style>
</head>
<body>
<header>
  <h1>ButtonGridTool ‚Äì iPhone Wizard</h1>
  <div class="hdrBtns">
    <button id="btnDonate" title="Spenden">‚òïÔ∏è</button>
    <button id="btnGear" title="Einstellungen">‚öôÔ∏è</button>
  </div>
</header>

<main>
  <!-- STEP 1 FRONT -->
  <div class="card">
    <div class="stepTitle">
      <span>Step 1 ‚Äì Front</span>
      <span id="frontState" class="badge warn">nicht geladen</span>
    </div>

    <input id="frontCam" type="file" accept="image/*" capture="environment" hidden />
    <input id="frontPick" type="file" accept="image/*" hidden />

    <div class="row">
      <button id="btnFrontCam" class="primary">üì∑ Foto machen</button>
      <button id="btnFrontPick">üìÅ Datei benutzen</button>

      <button id="btnFrontManual" disabled>Manuell 4 Ecken</button>
      <button id="btnFrontWarp" class="primary" disabled>Entzerren (A4)</button>
      <button id="btnFrontSkipWarp" disabled>Ohne Entzerren weiter</button>

      <button id="btnFrontResetView" class="toolbtn" disabled>Reset View</button>
    </div>

    <canvas id="frontCanvas" width="1200" height="900"></canvas>

    <p class="small">
      <b>Ecken setzen:</b> Tippe 4√ó: <b>TL ‚Üí TR ‚Üí BR ‚Üí BL</b>. Danach Punkte ziehen. <br>
      <b>Zoom/Pan:</b> Pinch-Zoom + ziehen. Punkte bleiben stabil. Dann <b>Entzerren</b> (oder <b>Ohne Entzerren</b>).
    </p>
  </div>

  <!-- STEP 2 BACK -->
  <div class="card">
    <div class="stepTitle">
      <span>Step 2 ‚Äì Back</span>
      <span id="backState" class="badge warn">wartet</span>
    </div>

    <input id="backCam" type="file" accept="image/*" capture="environment" hidden />
    <input id="backPick" type="file" accept="image/*" hidden />

    <div class="row">
      <button id="btnBackCam" class="primary" disabled>üì∑ Foto machen</button>
      <button id="btnBackPick" disabled>üìÅ Datei benutzen</button>

      <button id="btnBackManual" disabled>Manuell 4 Ecken</button>
      <button id="btnBackWarp" class="primary" disabled>Entzerren (A4)</button>
      <button id="btnBackSkipWarp" disabled>Ohne Entzerren weiter</button>

      <button id="btnBackResetView" class="toolbtn" disabled>Reset View</button>
    </div>

    <canvas id="backCanvas" width="1200" height="900"></canvas>
    <p class="small muted">
      Tipp: Wenn du ohne Entzerren arbeitest, mach Front/Back m√∂glichst gleich: gleiche Entfernung, gleicher Winkel.
    </p>
  </div>

  <!-- STEP 3 GRID -->
  <div class="card">
    <div class="stepTitle">
      <span>Step 3 ‚Äì Grid</span>
      <span id="gridState" class="badge warn">wartet auf Front</span>
    </div>

    <div class="row">
      <span class="pill"><b>Ansicht</b>
        <select id="gridWhich">
          <option value="front" selected>Front</option>
          <option value="back">Back</option>
        </select>
      </span>

      <span class="pill"><b>Mode</b>
        <select id="gridMode">
          <option value="V" selected>Vertikal</option>
          <option value="H">Horizontal</option>
        </select>
      </span>

      <button id="btnUndo" disabled>‚Ü©Ô∏é Schritt zur√ºck</button>
      <button id="btnGridResetView" class="toolbtn" disabled>Reset View</button>

      <button id="btnGridClear" class="danger" disabled>Alles l√∂schen</button>
      <button id="btnGridSave" disabled>Save</button>
      <input id="gridLoad" type="file" accept="application/json" hidden />
      <button id="btnGridLoad" disabled>Load</button>

      <button id="btnGridApply" class="primary" disabled>Grid anwenden</button>
    </div>

    <canvas id="gridCanvas" width="1200" height="900"></canvas>

    <p class="small">
      <b>Linien:</b> Tap = Linie setzen ¬∑ <b>Pinch/Drag = Zoom/Pan</b> (setzt keine Linien) <br>
      <b>Zellen:</b> <b>Doppeltipp</b> auf eine Zelle = aus/ein (aus = rot, wird nicht exportiert) <br>
      <b>Back check:</b> Umschalten auf <b>Back</b> und schauen, ob was abgeschnitten w√§re.
    </p>
  </div>

  <!-- STEP 4 PREVIEW -->
  <div class="card">
    <div class="stepTitle">
      <span>Step 4 ‚Äì Preview</span>
      <span id="prevState" class="badge warn">wartet</span>
    </div>

    <div class="row">
      <span class="pill"><b>Knopf #</b>
        <input id="idx" type="number" value="1" min="1" step="1" style="width:90px;">
      </span>
      <button id="btnPreview" class="primary" disabled>Preview</button>
    </div>

    <div class="split">
      <div>
        <p class="small"><b>Front</b></p>
        <canvas id="knobFront" width="900" height="450"></canvas>
      </div>
      <div>
        <p class="small" id="rightPrevLabel"><b>Back</b></p>
        <canvas id="knobRight" width="900" height="450"></canvas>
      </div>
    </div>
  </div>

  <!-- STEP 5 EXPORT -->
  <div class="card">
    <div class="stepTitle">
      <span>Step 5 ‚Äì Export</span>
      <span id="expState" class="badge warn">wartet</span>
    </div>
    <div class="row">
      <button id="btnExport" class="primary" disabled>ZIP Export</button>
    </div>
    <p id="status" class="small">Status: OpenCV.js l√§dt‚Ä¶</p>
  </div>
</main>

<!-- SETTINGS MODAL -->
<div id="settingsBackdrop" class="modalBackdrop">
  <div class="modal">
    <div class="modalHeader">
      <h2>‚öôÔ∏è Einstellungen</h2>
      <button id="btnSettingsClose">Schlie√üen</button>
    </div>
    <p class="muted">Export/Qualit√§t/Tight/Pad/Pairs.</p>
    <div class="hr"></div>

    <div class="row">
      <span class="pill"><b>Format</b>
        <select id="fmt">
          <option value="jpg" selected>JPG</option>
          <option value="png">PNG</option>
        </select>
      </span>

      <span class="pill"><b>JPG Q</b>
        <input id="jpgq" type="range" min="50" max="100" value="92" />
        <span id="jpgqLabel">92</span>
      </span>

      <span class="pill"><b>Pairs</b>
        <input id="pairs" type="checkbox" checked />
      </span>
    </div>

    <div class="row" style="margin-top:10px;">
      <span class="pill"><b>Tight</b>
        <input id="tight" type="checkbox" checked />
      </span>

      <span class="pill"><b>Tight-Pad</b>
        <input id="tightPad" type="number" value="12" min="0" max="200" step="1" style="width:90px;">
      </span>

      <span class="pill"><b>Min-Ratio</b>
        <input id="minRatio" type="number" value="0.005" min="0.0001" max="0.5" step="0.001" style="width:110px;">
      </span>

      <span class="pill"><b>Safety Keep</b>
        <input id="keep" type="number" value="0.05" min="0.0" max="1.0" step="0.01" style="width:90px;">
      </span>

      <span class="pill"><b>Grid-Pad</b>
        <input id="gridPad" type="number" value="15" min="0" max="300" step="1" style="width:90px;">
      </span>
    </div>
  </div>
</div>

<!-- DONATE MODAL -->
<div id="donateBackdrop" class="modalBackdrop">
  <div class="modal">
    <div class="modalHeader">
      <h2>‚òïÔ∏è Spenden</h2>
      <button id="btnDonateClose">Schlie√üen</button>
    </div>
    <p class="small">
      Wenn dir das Tool Zeit spart (oder Nerven, was ja quasi Lebenszeit ist):<br>
      <b>PayPal</b> oder <b>Bitcoin</b> ‚Äì beides geht.
    </p>

    <div class="hr"></div>

    <p class="muted"><b>PayPal</b></p>
    <div class="copyRow">
      <div class="copyBox mono" id="paypalText">https://paypal.me/DEINPAYPALNAME</div>
      <button id="btnCopyPayPal">Kopieren</button>
    </div>

    <div class="hr"></div>

    <p class="muted"><b>Bitcoin (BTC)</b></p>
    <div class="copyRow">
      <div class="copyBox mono" id="btcText">bc1qwr08y9ngmvplpr8tuk4w34rl4pkryur8u4cf5f</div>
      <button id="btnCopyBTC">Kopieren</button>
    </div>

    <p class="small muted" style="margin-top:10px;">
      (Links/Adresse kannst du jederzeit im HTML austauschen.)
    </p>
  </div>
</div>

<!-- hidden warp canvases -->
<canvas id="frontWarpCanvas" width="2480" height="3508" hidden></canvas>
<canvas id="backWarpCanvas" width="2480" height="3508" hidden></canvas>

<script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
<script async src="https://docs.opencv.org/4.x/opencv.js"></script>

<script>
/* ----------------- Utils ----------------- */
const $ = (id)=>document.getElementById(id);
const statusEl = $("status");
function setStatus(s){ statusEl.textContent = "Status: " + s; }
function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
function clampScale(s){ return clamp(s, 1, 6); }
function pad3(n){ return String(n).padStart(3,"0"); }

function downloadBlob(blob, filename){
  const a=document.createElement("a");
  a.href=URL.createObjectURL(blob);
  a.download=filename;
  document.body.appendChild(a);
  a.click();
  a.remove();
  setTimeout(()=>URL.revokeObjectURL(a.href), 1000);
}

async function copyText(t){
  try{
    await navigator.clipboard.writeText(t);
    setStatus("Kopiert.");
  }catch{
    // fallback
    const ta=document.createElement("textarea");
    ta.value=t; document.body.appendChild(ta);
    ta.select(); document.execCommand("copy");
    ta.remove();
    setStatus("Kopiert (fallback).");
  }
}

/* modals */
$("btnGear").addEventListener("click", ()=> $("settingsBackdrop").style.display="flex");
$("btnSettingsClose").addEventListener("click", ()=> $("settingsBackdrop").style.display="none");
$("settingsBackdrop").addEventListener("click", (e)=>{ if(e.target=== $("settingsBackdrop")) $("settingsBackdrop").style.display="none"; });

$("btnDonate").addEventListener("click", ()=> $("donateBackdrop").style.display="flex");
$("btnDonateClose").addEventListener("click", ()=> $("donateBackdrop").style.display="none");
$("donateBackdrop").addEventListener("click", (e)=>{ if(e.target=== $("donateBackdrop")) $("donateBackdrop").style.display="none"; });

$("btnCopyPayPal").addEventListener("click", ()=> copyText($("paypalText").textContent.trim()));
$("btnCopyBTC").addEventListener("click", ()=> copyText($("btcText").textContent.trim()));

$("jpgq").addEventListener("input", ()=> $("jpgqLabel").textContent = $("jpgq").value);
$("jpgqLabel").textContent = $("jpgq").value;

/* robust iOS image load */
async function loadImageFileToCanvas(file){
  const url = URL.createObjectURL(file);
  try{
    const img = new Image();
    img.decoding = "async";
    img.src = url;
    await img.decode();
    const c = document.createElement("canvas");
    c.width = img.naturalWidth;
    c.height = img.naturalHeight;
    c.getContext("2d").drawImage(img, 0, 0);
    return c;
  } finally {
    URL.revokeObjectURL(url);
  }
}

function localPoint(canvas, e){
  const r=canvas.getBoundingClientRect();
  return {
    x:(e.clientX-r.left)*(canvas.width/r.width),
    y:(e.clientY-r.top)*(canvas.height/r.height)
  };
}

/* ----------------- State ----------------- */
const A4_W=2480, A4_H=3508;

const S = {
  cvReady:false,

  // original images as canvases
  frontImg:null,
  backImg:null,

  // manual points in IMAGE coords
  pts: { front:[], back:[] },

  // view transforms for photo canvases
  view: {
    front:{scale:1, ox:0, oy:0},
    back :{scale:1, ox:0, oy:0},
    grid :{scale:1, ox:0, oy:0}
  },

  // pointer state for photos
  pointers:new Map(),
  pinch:null,
  dragPoint:null,
  pan:null,

  // "working" canvases used for grid/export:
  // either warped A4 canvases, or original raw canvases
  work: { front:null, back:null, mode:"none" }, // mode: "warp" | "raw"

  // grid stored as RELATIVE (0..1), so it applies to both front/back sizes
  xRel:[],
  yRel:[],

  // disabled cell indices (1-based)
  disabledCells:new Set(),

  // undo stack for grid operations
  undo:[],

  // grid interaction state
  gridPointers:new Map(),
  gridPinch:null,
  gridPan:null,
  gridLastTap:{t:0, x:0, y:0},
  gridGestureLockUntil:0,
};

/* ----------------- OpenCV init ----------------- */
window.Module = window.Module || {};
Module.onRuntimeInitialized = () => {
  S.cvReady = true;
  setStatus("bereit. OpenCV.js ist geladen.");
};

/* ----------------- UI: file pickers ----------------- */
$("btnFrontCam").addEventListener("click", ()=> $("frontCam").click());
$("btnFrontPick").addEventListener("click", ()=> $("frontPick").click());
$("btnBackCam").addEventListener("click", ()=> $("backCam").click());
$("btnBackPick").addEventListener("click", ()=> $("backPick").click());

$("frontCam").addEventListener("change", (e)=> loadSide(e, "front"));
$("frontPick").addEventListener("change", (e)=> loadSide(e, "front"));
$("backCam").addEventListener("change", (e)=> loadSide(e, "back"));
$("backPick").addEventListener("change", (e)=> loadSide(e, "back"));

async function loadSide(e, which){
  const f = e.target.files?.[0];
  if(!f) return;
  const imgCanvas = await loadImageFileToCanvas(f);

  S.pts[which]=[];
  S.view[which]={scale:1, ox:0, oy:0};

  if(which==="front"){
    S.frontImg = imgCanvas;
    $("frontState").textContent="geladen";
    $("frontState").className="badge ok";
    $("btnFrontManual").disabled=false;
    $("btnFrontWarp").disabled=true;
    $("btnFrontSkipWarp").disabled=false;
    $("btnFrontResetView").disabled=false;

    $("btnBackCam").disabled=false;
    $("btnBackPick").disabled=false;
    $("backState").textContent="wartet (Back laden)";
    $("backState").className="badge warn";

    hookPhotoCanvas("front");
    renderPhoto("front");
    setStatus("Front geladen. Entzerren oder 'Ohne Entzerren weiter'.");
  } else {
    S.backImg = imgCanvas;
    $("backState").textContent="geladen";
    $("backState").className="badge ok";
    $("btnBackManual").disabled=false;
    $("btnBackWarp").disabled=true;
    $("btnBackSkipWarp").disabled=false;
    $("btnBackResetView").disabled=false;

    hookPhotoCanvas("back");
    renderPhoto("back");
    setStatus("Back geladen. Entzerren oder 'Ohne Entzerren weiter'.");
  }
}

/* ----------------- Photo: manual corners + zoom/pan ----------------- */
$("btnFrontManual").addEventListener("click", ()=> startManual("front"));
$("btnBackManual").addEventListener("click", ()=> startManual("back"));
$("btnFrontWarp").addEventListener("click", ()=> warpA4("front"));
$("btnBackWarp").addEventListener("click", ()=> warpA4("back"));
$("btnFrontSkipWarp").addEventListener("click", ()=> useRaw("front"));
$("btnBackSkipWarp").addEventListener("click", ()=> useRaw("back"));
$("btnFrontResetView").addEventListener("click", ()=>{ S.view.front={scale:1,ox:0,oy:0}; renderPhoto("front"); });
$("btnBackResetView").addEventListener("click", ()=>{ S.view.back ={scale:1,ox:0,oy:0}; renderPhoto("back"); });

function startManual(which){
  S.pts[which]=[];
  if(which==="front") $("btnFrontWarp").disabled=true;
  else $("btnBackWarp").disabled=true;
  setStatus(`${which.toUpperCase()}: 4√ó tippen (TL‚ÜíTR‚ÜíBR‚ÜíBL). Danach Punkte ziehen + Pinch/Pan m√∂glich.`);
  renderPhoto(which);
}

function hookPhotoCanvas(which){
  const canvas = which==="front" ? $("frontCanvas") : $("backCanvas");
  canvas.onpointerdown = (e)=> photoPointerDown(which, canvas, e);
  canvas.onpointermove = (e)=> photoPointerMove(which, canvas, e);
  canvas.onpointerup   = (e)=> photoPointerUp(which, canvas, e);
  canvas.onpointercancel = (e)=> photoPointerUp(which, canvas, e);
}

function renderPhoto(which){
  const canvas = which==="front" ? $("frontCanvas") : $("backCanvas");
  const img = which==="front" ? S.frontImg : S.backImg;
  if(!img){
    const ctx=canvas.getContext("2d");
    ctx.setTransform(1,0,0,1,0,0);
    ctx.clearRect(0,0,canvas.width,canvas.height);
    return;
  }

  const ctx=canvas.getContext("2d");
  ctx.setTransform(1,0,0,1,0,0);
  ctx.clearRect(0,0,canvas.width,canvas.height);

  const baseR = Math.min(canvas.width/img.width, canvas.height/img.height);
  const baseW = img.width*baseR, baseH = img.height*baseR;
  const baseX = (canvas.width-baseW)/2, baseY = (canvas.height-baseH)/2;

  const v=S.view[which];
  ctx.save();
  ctx.translate(baseX+v.ox, baseY+v.oy);
  ctx.scale(v.scale, v.scale);
  ctx.drawImage(img, 0,0, baseW, baseH);
  ctx.restore();

  drawPhotoOverlay(which, {baseR, baseX, baseY});
}

function imgToView(which, pImg, fit){
  const canvas = which==="front" ? $("frontCanvas") : $("backCanvas");
  const img = which==="front" ? S.frontImg : S.backImg;
  const baseR = fit.baseR;
  const baseX = fit.baseX;
  const baseY = fit.baseY;
  const v=S.view[which];
  const x = baseX + v.ox + (pImg.x*baseR)*v.scale;
  const y = baseY + v.oy + (pImg.y*baseR)*v.scale;
  return {x,y};
}

function viewToImg(which, pView){
  const canvas = which==="front" ? $("frontCanvas") : $("backCanvas");
  const img = which==="front" ? S.frontImg : S.backImg;
  const baseR = Math.min(canvas.width/img.width, canvas.height/img.height);
  const baseW = img.width*baseR, baseH=img.height*baseR;
  const baseX = (canvas.width-baseW)/2, baseY=(canvas.height-baseH)/2;
  const v=S.view[which];

  const x = (pView.x - (baseX+v.ox)) / v.scale;
  const y = (pView.y - (baseY+v.oy)) / v.scale;

  const ix = x / baseR;
  const iy = y / baseR;
  return { x:clamp(ix,0,img.width-1), y:clamp(iy,0,img.height-1) };
}

function drawPhotoOverlay(which, fit){
  const canvas = which==="front" ? $("frontCanvas") : $("backCanvas");
  const ctx=canvas.getContext("2d");
  const pts=S.pts[which];

  ctx.save();
  ctx.lineWidth=4;

  if(pts.length===4){
    ctx.strokeStyle="rgba(0,255,120,.95)";
    ctx.beginPath();
    const p0=imgToView(which, pts[0], fit);
    ctx.moveTo(p0.x,p0.y);
    for(let i=1;i<4;i++){
      const pi=imgToView(which, pts[i], fit);
      ctx.lineTo(pi.x,pi.y);
    }
    ctx.closePath();
    ctx.stroke();
  }

  const R=16;
  for(let i=0;i<pts.length;i++){
    const pv=imgToView(which, pts[i], fit);
    ctx.fillStyle="rgba(0,0,0,.35)";
    ctx.beginPath(); ctx.arc(pv.x,pv.y,R+10,0,Math.PI*2); ctx.fill();
    ctx.fillStyle="rgba(0,255,120,.95)";
    ctx.beginPath(); ctx.arc(pv.x,pv.y,R,0,Math.PI*2); ctx.fill();
    ctx.fillStyle="#000";
    ctx.font="20px -apple-system";
    ctx.fillText(String(i+1), pv.x+R+8, pv.y-8);
  }

  if(pts.length<4){
    ctx.fillStyle="rgba(255,255,255,.95)";
    ctx.font="22px -apple-system";
    ctx.fillText(`Tippe Ecke ${pts.length+1}/4`, 16, 34);
  }
  ctx.restore();
}

function nearestPhotoHandle(which, pView){
  const pts=S.pts[which];
  if(!pts.length) return null;
  const canvas = which==="front" ? $("frontCanvas") : $("backCanvas");
  const img = which==="front" ? S.frontImg : S.backImg;
  const baseR = Math.min(canvas.width/img.width, canvas.height/img.height);
  const baseW = img.width*baseR, baseH=img.height*baseR;
  const baseX = (canvas.width-baseW)/2, baseY=(canvas.height-baseH)/2;
  const fit={baseR, baseX, baseY};

  let best=null;
  for(let i=0;i<pts.length;i++){
    const pv=imgToView(which, pts[i], fit);
    const d=Math.hypot(pv.x-pView.x, pv.y-pView.y);
    if(best===null || d<best.d) best={i,d};
  }
  if(best && best.d<55) return best.i;
  return null;
}

function photoPointerDown(which, canvas, e){
  canvas.setPointerCapture(e.pointerId);
  const p=localPoint(canvas,e);
  S.pointers.set(e.pointerId, p);

  if(S.pointers.size===2){
    const a=[...S.pointers.values()];
    const d=Math.hypot(a[0].x-a[1].x, a[0].y-a[1].y);
    S.pinch={which, startDist:d, startScale:S.view[which].scale};
    S.dragPoint=null;
    S.pan=null;
    return;
  }

  const hit=nearestPhotoHandle(which, p);
  if(hit!==null){
    S.dragPoint={which, idx:hit};
    return;
  }

  S.pan={which, x:p.x, y:p.y, moved:false, maybeTap:true};
}

function photoPointerMove(which, canvas, e){
  if(!S.pointers.has(e.pointerId)) return;
  const p=localPoint(canvas,e);
  S.pointers.set(e.pointerId, p);

  if(S.pointers.size===2 && S.pinch && S.pinch.which===which){
    const a=[...S.pointers.values()];
    const d=Math.hypot(a[0].x-a[1].x, a[0].y-a[1].y);
    const ratio=d/(S.pinch.startDist||1);
    S.view[which].scale = clampScale(S.pinch.startScale*ratio);
    renderPhoto(which);
    return;
  }

  if(S.dragPoint && S.dragPoint.which===which){
    const pts=S.pts[which];
    pts[S.dragPoint.idx]=viewToImg(which, p);
    renderPhoto(which);
    return;
  }

  if(S.pan && S.pan.which===which){
    const dx=p.x-S.pan.x, dy=p.y-S.pan.y;
    if(Math.hypot(dx,dy)>8){ S.pan.moved=true; S.pan.maybeTap=false; }
    S.view[which].ox += dx;
    S.view[which].oy += dy;
    S.pan.x=p.x; S.pan.y=p.y;
    renderPhoto(which);
  }
}

function photoPointerUp(which, canvas, e){
  const p=localPoint(canvas,e);
  S.pointers.delete(e.pointerId);
  if(S.pointers.size<2) S.pinch=null;

  if(S.pan && S.pan.which===which && S.pan.maybeTap){
    const pts=S.pts[which];
    if(pts.length<4){
      pts.push(viewToImg(which, p));
      renderPhoto(which);
      if(pts.length===4){
        if(which==="front") $("btnFrontWarp").disabled=false;
        else $("btnBackWarp").disabled=false;
        setStatus(`${which.toUpperCase()}: 4 Punkte gesetzt ‚Üí Entzerren m√∂glich.`);
      }else{
        setStatus(`${which.toUpperCase()}: Punkt ${pts.length}/4 gesetzt.`);
      }
    }
  }

  S.dragPoint=null;
  S.pan=null;
}

/* ----------------- WORK MODE: raw / warp ----------------- */
function enableGridUI(){
  const readyFront = !!S.work.front;
  const readyBack  = !!S.work.back;

  if(readyFront){
    $("gridState").textContent = readyBack ? "Front+Back ok ‚Üí Grid m√∂glich" : "Front ok ‚Üí Back fehlt";
    $("gridState").className = readyBack ? "badge ok" : "badge warn";

    $("btnUndo").disabled = false;
    $("btnGridResetView").disabled = false;
    $("btnGridClear").disabled = false;
    $("btnGridSave").disabled = false;
    $("btnGridLoad").disabled = false;
    $("btnGridApply").disabled = !readyBack;
    hookGridCanvas();
    renderGrid();
  }else{
    $("gridState").textContent="wartet auf Front";
    $("gridState").className="badge warn";
  }
}

function useRaw(which){
  if(which==="front" && !S.frontImg) return;
  if(which==="back" && !S.backImg) return;

  S.work.mode = "raw";
  if(which==="front"){
    S.work.front = S.frontImg;
    $("frontState").textContent="raw (ohne entzerren)";
    $("frontState").className="badge ok";
  } else {
    S.work.back = S.backImg;
    $("backState").textContent="raw (ohne entzerren)";
    $("backState").className="badge ok";
  }
  setStatus(`${which.toUpperCase()}: Weiter ohne Entzerren. Jetzt andere Seite ebenfalls bereit machen.`);
  enableGridUI();
}

/* ----------------- Warp (OpenCV) ----------------- */
function canvasToCvSrc(canvasEl){ return cv.imread(canvasEl); }

async function warpA4(which){
  if(!S.cvReady){
    alert("OpenCV.js l√§dt noch. Bitte kurz warten und nochmal.");
    return;
  }
  const img = which==="front" ? S.frontImg : S.backImg;
  const pts = S.pts[which];
  if(!img || pts.length!==4){
    alert("Bitte 4 Ecken setzen (TL‚ÜíTR‚ÜíBR‚ÜíBL).");
    return;
  }

  setStatus(`${which.toUpperCase()}: Entzerren l√§uft‚Ä¶`);

  try{
    const src = canvasToCvSrc(img);

    const srcTri = cv.matFromArray(4,1,cv.CV_32FC2,[
      pts[0].x, pts[0].y,
      pts[1].x, pts[1].y,
      pts[2].x, pts[2].y,
      pts[3].x, pts[3].y
    ]);
    const dstTri = cv.matFromArray(4,1,cv.CV_32FC2,[
      0,0,  A4_W,0,  A4_W,A4_H,  0,A4_H
    ]);

    const M = cv.getPerspectiveTransform(srcTri, dstTri);
    const dst = new cv.Mat();
    cv.warpPerspective(src, dst, M, new cv.Size(A4_W,A4_H), cv.INTER_LINEAR, cv.BORDER_CONSTANT, new cv.Scalar(255,255,255,255));

    const outCanvas = which==="front" ? $("frontWarpCanvas") : $("backWarpCanvas");
    cv.imshow(outCanvas, dst);

    src.delete(); dst.delete(); M.delete(); srcTri.delete(); dstTri.delete();

    S.work.mode="warp";
    if(which==="front"){
      S.work.front = outCanvas;
      $("frontState").textContent="entzerrt";
      $("frontState").className="badge ok";
    } else {
      S.work.back = outCanvas;
      $("backState").textContent="entzerrt";
      $("backState").className="badge ok";
    }

    setStatus(`${which.toUpperCase()}: Entzerrt. Jetzt andere Seite bereit machen, dann Grid.`);
    enableGridUI();
  }catch(err){
    console.error(err);
    alert("Entzerren fehlgeschlagen (siehe Konsole).");
    setStatus("Entzerren fehlgeschlagen.");
  }
}

/* ----------------- Grid: render + interactions ----------------- */
$("btnGridResetView").addEventListener("click", ()=>{ S.view.grid={scale:1,ox:0,oy:0}; renderGrid(); });

$("btnGridClear").addEventListener("click", ()=>{
  S.xRel=[]; S.yRel=[];
  S.disabledCells.clear();
  S.undo=[];
  renderGrid();
  setStatus("Alles gel√∂scht.");
});

$("btnUndo").addEventListener("click", ()=>{
  const a = S.undo.pop();
  if(!a) return;

  if(a.type==="addLine"){
    const arr = a.axis==="x" ? S.xRel : S.yRel;
    const i = arr.findIndex(v=>Math.abs(v-a.value)<1e-9);
    if(i>=0) arr.splice(i,1);
  }else if(a.type==="toggleCell"){
    if(a.toDisabled) S.disabledCells.delete(a.idx);
    else S.disabledCells.add(a.idx);
  }
  renderGrid();
  setStatus("Schritt zur√ºck.");
});

$("btnGridSave").addEventListener("click", ()=>{
  if(!S.work.front) return alert("Erst Front bereit machen.");
  const data = {
    version:2,
    x_rel: [...S.xRel].sort((a,b)=>a-b),
    y_rel: [...S.yRel].sort((a,b)=>a-b),
    disabled: [...S.disabledCells].sort((a,b)=>a-b)
  };
  downloadBlob(new Blob([JSON.stringify(data,null,2)],{type:"application/json"}),"grid.json");
});

$("btnGridLoad").addEventListener("click", ()=> $("gridLoad").click());
$("gridLoad").addEventListener("change", async (e)=>{
  const f=e.target.files?.[0]; if(!f) return;
  const j=JSON.parse(await f.text());
  S.xRel = (j.x_rel||[]).map(Number);
  S.yRel = (j.y_rel||[]).map(Number);
  S.disabledCells = new Set(j.disabled||[]);
  S.undo=[];
  renderGrid();
  setStatus("Grid geladen.");
});

$("gridWhich").addEventListener("change", ()=> renderGrid());

$("btnGridApply").addEventListener("click", ()=>{
  if(!S.work.front) return alert("Front fehlt.");
  if(!S.work.back)  return alert("Back fehlt.");

  buildCells();
  const ok = S.cells.length>0;

  $("btnPreview").disabled = !ok;
  $("btnExport").disabled  = !ok;

  $("prevState").textContent = ok ? "bereit" : "wartet";
  $("prevState").className = ok ? "badge ok" : "badge warn";
  $("expState").textContent  = ok ? "bereit" : "wartet";
  $("expState").className  = ok ? "badge ok" : "badge warn";

  setStatus(ok ? `Grid angewandt: ${S.cells.length} Zellen (${S.disabledCells.size} deaktiviert).`
               : "Grid ergibt keine Zellen.");
});

function hookGridCanvas(){
  const c=$("gridCanvas");
  c.onpointerdown = (e)=> gridPointerDown(c,e);
  c.onpointermove = (e)=> gridPointerMove(c,e);
  c.onpointerup   = (e)=> gridPointerUp(c,e);
  c.onpointercancel = (e)=> gridPointerUp(c,e);
}

function gridFitFor(workCanvas){
  const c=$("gridCanvas");
  const iw = workCanvas.width, ih = workCanvas.height;
  const rr0 = Math.min(c.width/iw, c.height/ih);
  const gv=S.view.grid;
  const rr = rr0*gv.scale;
  const w=iw*rr, h=ih*rr;
  const ox=(c.width-w)/2 + gv.ox;
  const oy=(c.height-h)/2 + gv.oy;
  return {rr, ox, oy, w, h, iw, ih};
}

function viewToImgCoord(workCanvas, x, y){
  const {rr, ox, oy, iw, ih} = gridFitFor(workCanvas);
  return { ix:(x-ox)/rr, iy:(y-oy)/rr, iw, ih };
}

function relXtoPx(workCanvas, r){ return Math.round(r * workCanvas.width); }
function relYtoPx(workCanvas, r){ return Math.round(r * workCanvas.height); }

function renderGrid(){
  const c=$("gridCanvas");
  const ctx=c.getContext("2d");
  ctx.setTransform(1,0,0,1,0,0);
  ctx.clearRect(0,0,c.width,c.height);

  const which = $("gridWhich").value;
  const work = which==="front" ? S.work.front : S.work.back;

  if(!work){
    ctx.fillStyle="#111"; ctx.fillRect(0,0,c.width,c.height);
    ctx.fillStyle="#fff"; ctx.font="24px -apple-system";
    ctx.fillText("Erst Front/Back bereit machen.", 20, 50);
    return;
  }

  const fit = gridFitFor(work);
  ctx.drawImage(work, fit.ox, fit.oy, fit.w, fit.h);

  const xs=[0, ...S.xRel.map(r=>relXtoPx(work,r)).sort((a,b)=>a-b), work.width];
  const ys=[0, ...S.yRel.map(r=>relYtoPx(work,r)).sort((a,b)=>a-b), work.height];

  // disabled overlays
  ctx.save();
  ctx.fillStyle="rgba(255,0,0,0.18)";
  let idx=1;
  for(let r=0;r<ys.length-1;r++){
    for(let cc=0;cc<xs.length-1;cc++){
      if(S.disabledCells.has(idx)){
        const x0=xs[cc], x1=xs[cc+1];
        const y0=ys[r],  y1=ys[r+1];
        ctx.fillRect(fit.ox + x0*fit.rr, fit.oy + y0*fit.rr, (x1-x0)*fit.rr, (y1-y0)*fit.rr);
      }
      idx++;
    }
  }
  ctx.restore();

  // lines
  ctx.save();
  ctx.lineWidth=2;
  ctx.strokeStyle="rgba(0,120,255,0.92)";
  for(const xv of xs){
    const X=fit.ox + xv*fit.rr;
    ctx.beginPath(); ctx.moveTo(X,fit.oy); ctx.lineTo(X,fit.oy+fit.h); ctx.stroke();
  }
  for(const yv of ys){
    const Y=fit.oy + yv*fit.rr;
    ctx.beginPath(); ctx.moveTo(fit.ox,Y); ctx.lineTo(fit.ox+fit.w,Y); ctx.stroke();
  }
  ctx.restore();

  // numbers thick
  ctx.save();
  ctx.font="78px -apple-system";
  ctx.lineWidth=12;
  ctx.strokeStyle="rgba(0,0,0,0.85)";
  ctx.fillStyle="rgba(0,160,255,0.98)";
  ctx.shadowColor="rgba(0,0,0,0.35)";
  ctx.shadowBlur=8;

  idx=1;
  for(let r=0;r<ys.length-1;r++){
    for(let cc=0;cc<xs.length-1;cc++){
      const tx=fit.ox + xs[cc]*fit.rr + 14;
      const ty=fit.oy + ys[r]*fit.rr + 88;
      ctx.strokeText(String(idx), tx, ty);
      ctx.fillText(String(idx), tx, ty);
      idx++;
    }
  }
  ctx.restore();
}

/* --- grid interactions: pinch/pan never sets lines --- */
function gridPointerDown(canvas, e){
  if(!S.work.front) return;
  canvas.setPointerCapture(e.pointerId);
  const p=localPoint(canvas,e);
  S.gridPointers.set(e.pointerId, p);

  // if multi-touch begins, lock taps briefly
  if(S.gridPointers.size>=2){
    S.gridGestureLockUntil = Date.now() + 350;
    S.gridPinchStart();
    return;
  }

  // single pointer: start pan candidate (but tap allowed if not moved)
  S.gridPan={x:p.x, y:p.y, moved:false};
}

function gridPointerMove(canvas, e){
  if(!S.gridPointers.has(e.pointerId)) return;
  const p=localPoint(canvas,e);
  S.gridPointers.set(e.pointerId, p);

  if(S.gridPointers.size>=2){
    S.gridGestureLockUntil = Date.now() + 350;
    // pinch zoom
    const a=[...S.gridPointers.values()];
    const d=Math.hypot(a[0].x-a[1].x, a[0].y-a[1].y);
    if(!S.gridPinch) S.gridPinchStart();
    const ratio=d/(S.gridPinch.startDist||1);
    S.view.grid.scale = clampScale(S.gridPinch.startScale*ratio);
    renderGrid();
    return;
  }

  if(S.gridPan){
    const dx=p.x-S.gridPan.x, dy=p.y-S.gridPan.y;
    if(Math.hypot(dx,dy)>10){ S.gridPan.moved=true; S.gridGestureLockUntil = Date.now() + 250; }
    S.view.grid.ox += dx;
    S.view.grid.oy += dy;
    S.gridPan.x=p.x; S.gridPan.y=p.y;
    renderGrid();
  }
}

function gridPointerUp(canvas, e){
  const p=localPoint(canvas,e);
  S.gridPointers.delete(e.pointerId);

  if(S.gridPointers.size<2){
    S.gridPinch=null;
  }

  // if we were panning or in gesture lock window -> do nothing
  if(S.gridPan && S.gridPan.moved){ S.gridPan=null; return; }
  S.gridPan=null;

  if(Date.now() < S.gridGestureLockUntil){
    return; // swallow tap after pinch/pan
  }

  // double tap cell toggle
  const now=Date.now();
  const dt = now - S.gridLastTap.t;
  const dd = Math.hypot(p.x - S.gridLastTap.x, p.y - S.gridLastTap.y);
  S.gridLastTap = {t:now, x:p.x, y:p.y};

  if(dt < 320 && dd < 25){
    const idx = hitTestCell(p.x,p.y);
    if(idx!==null){
      const wasDisabled = S.disabledCells.has(idx);
      if(wasDisabled) S.disabledCells.delete(idx);
      else S.disabledCells.add(idx);

      S.undo.push({type:"toggleCell", idx, toDisabled: !wasDisabled});
      renderGrid();
      setStatus(`Zelle ${idx} ${S.disabledCells.has(idx) ? "deaktiviert" : "aktiviert"}.`);
    }
    return;
  }

  // single tap add line
  addLineFromTap(p.x,p.y);
}

S.gridPinchStart = function(){
  const a=[...S.gridPointers.values()];
  const d=Math.hypot(a[0].x-a[1].x, a[0].y-a[1].y);
  S.gridPinch={startDist:d, startScale:S.view.grid.scale};
};

function addLineFromTap(x,y){
  const which = $("gridWhich").value;
  const work = which==="front" ? S.work.front : S.work.back;
  if(!work) return;

  const {ix, iy, iw, ih} = viewToImgCoord(work, x, y);
  if(ix<0 || iy<0 || ix>iw || iy>ih) return;

  const mode=$("gridMode").value;
  if(mode==="V"){
    const r = clamp(ix/iw, 0, 1);
    const rr = Math.min(0.999999, Math.max(0.000001, r));
    if(!S.xRel.some(v=>Math.abs(v-rr)<1e-9)){
      S.xRel.push(rr);
      S.xRel.sort((a,b)=>a-b);
      S.undo.push({type:"addLine", axis:"x", value:rr});
    }
  }else{
    const r = clamp(iy/ih, 0, 1);
    const rr = Math.min(0.999999, Math.max(0.000001, r));
    if(!S.yRel.some(v=>Math.abs(v-rr)<1e-9)){
      S.yRel.push(rr);
      S.yRel.sort((a,b)=>a-b);
      S.undo.push({type:"addLine", axis:"y", value:rr});
    }
  }
  renderGrid();
}

function hitTestCell(viewX, viewY){
  const which = $("gridWhich").value;
  const work = which==="front" ? S.work.front : S.work.back;
  if(!work) return null;

  const {ix, iy} = viewToImgCoord(work, viewX, viewY);
  if(ix<0 || iy<0 || ix>work.width || iy>work.height) return null;

  const xs=[0, ...S.xRel.map(r=>Math.round(r*work.width)).sort((a,b)=>a-b), work.width];
  const ys=[0, ...S.yRel.map(r=>Math.round(r*work.height)).sort((a,b)=>a-b), work.height];

  let c=-1, r=-1;
  for(let i=0;i<xs.length-1;i++) if(ix>=xs[i] && ix<xs[i+1]){ c=i; break; }
  for(let j=0;j<ys.length-1;j++) if(iy>=ys[j] && iy<ys[j+1]){ r=j; break; }
  if(c<0 || r<0) return null;

  const cols = xs.length-1;
  return r*cols + c + 1;
}

/* ----------------- Cells + preview + export ----------------- */
S.cells=[];

function buildCells(){
  const pad = parseInt($("gridPad").value||"0",10);
  const workF = S.work.front;
  if(!workF){ S.cells=[]; return; }

  const xs=[0, ...S.xRel.map(r=>Math.round(r*workF.width)).sort((a,b)=>a-b), workF.width];
  const ys=[0, ...S.yRel.map(r=>Math.round(r*workF.height)).sort((a,b)=>a-b), workF.height];

  const cells=[];
  let idx=1;
  for(let r=0;r<ys.length-1;r++){
    for(let c=0;c<xs.length-1;c++){
      let x0=xs[c]+pad, x1=xs[c+1]-pad;
      let y0=ys[r]+pad, y1=ys[r+1]-pad;
      x0=clamp(x0,0,workF.width); x1=clamp(x1,0,workF.width);
      y0=clamp(y0,0,workF.height); y1=clamp(y1,0,workF.height);
      if(x1-x0>5 && y1-y0>5){
        cells.push({x0,y0,x1,y1, idx});
      }
      idx++;
    }
  }
  S.cells=cells;
}

function cropCanvas(srcCanvas, cell){
  const w=cell.x1-cell.x0, h=cell.y1-cell.y0;
  const c=document.createElement("canvas");
  c.width=w; c.height=h;
  c.getContext("2d").drawImage(srcCanvas, cell.x0,cell.y0,w,h, 0,0,w,h);
  return c;
}

function tightOrFull(cellCanvas){
  if(!$("tight").checked) return cellCanvas;

  const pad = parseInt($("tightPad").value||"0",10);
  const minRatio = parseFloat($("minRatio").value||"0.005");
  const keep = parseFloat($("keep").value||"0.05");

  const w=cellCanvas.width, h=cellCanvas.height;
  const ctx=cellCanvas.getContext("2d",{willReadFrequently:true});
  const img=ctx.getImageData(0,0,w,h);

  let minX=w, minY=h, maxX=0, maxY=0, count=0;
  const thr=245;
  for(let y=0;y<h;y++){
    for(let x=0;x<w;x++){
      const i=(y*w+x)*4;
      const r=img.data[i], g=img.data[i+1], b=img.data[i+2];
      if(r<thr || g<thr || b<thr){
        count++;
        if(x<minX) minX=x; if(y<minY) minY=y;
        if(x>maxX) maxX=x; if(y>maxY) maxY=y;
      }
    }
  }
  const ratio=count/(w*h);
  if(ratio<minRatio) return cellCanvas;

  minX=clamp(minX-pad,0,w-1); minY=clamp(minY-pad,0,h-1);
  maxX=clamp(maxX+pad,0,w-1); maxY=clamp(maxY+pad,0,h-1);

  const cw=maxX-minX+1, ch=maxY-minY+1;
  if((cw/w)<keep || (ch/h)<keep) return cellCanvas;

  const out=document.createElement("canvas");
  out.width=cw; out.height=ch;
  out.getContext("2d").drawImage(cellCanvas, minX,minY,cw,ch, 0,0,cw,ch);
  return out;
}

function drawFitTo(canvas, src){
  const ctx=canvas.getContext("2d");
  ctx.setTransform(1,0,0,1,0,0);
  ctx.clearRect(0,0,canvas.width,canvas.height);
  const r=Math.min(canvas.width/src.width, canvas.height/src.height);
  const w=src.width*r, h=src.height*r;
  const x=(canvas.width-w)/2, y=(canvas.height-h)/2;
  ctx.drawImage(src,x,y,w,h);
}

function buildPairCanvas(front, back){
  const pair=document.createElement("canvas");
  pair.width = front.width + back.width;
  pair.height = Math.max(front.height, back.height);
  const pctx=pair.getContext("2d");
  pctx.fillStyle="#fff"; pctx.fillRect(0,0,pair.width,pair.height);
  pctx.drawImage(front,0,0);
  pctx.drawImage(back,front.width,0);
  return pair;
}

$("pairs").addEventListener("change", ()=>{
  $("rightPrevLabel").innerHTML = $("pairs").checked ? "<b>Pair</b> (Front+Back)" : "<b>Back</b>";
});

$("btnPreview").addEventListener("click", ()=>{
  if(!S.work.front || !S.work.back) return alert("Front & Back m√ºssen bereit sein (entzerrt oder raw).");
  buildCells();
  if(!S.cells.length) return alert("Grid ergibt keine Zellen.");

  const idx = clamp(parseInt($("idx").value||"1",10), 1, S.cells.length);
  $("idx").value = idx;

  const cell = S.cells[idx-1];

  if(S.disabledCells.has(cell.idx)){
    setStatus(`Zelle ${cell.idx} ist deaktiviert (rot) ‚Äì wird nicht exportiert.`);
  }

  const f = tightOrFull(cropCanvas(S.work.front, cell));
  const b = tightOrFull(cropCanvas(S.work.back, cell));
  drawFitTo($("knobFront"), f);

  const doPairs = $("pairs").checked;
  if(doPairs){
    $("rightPrevLabel").innerHTML = "<b>Pair</b> (Front+Back)";
    drawFitTo($("knobRight"), buildPairCanvas(f,b));
  }else{
    $("rightPrevLabel").innerHTML = "<b>Back</b>";
    drawFitTo($("knobRight"), b);
  }
});

/* Export */
async function canvasToBlob(c, fmt, q){
  return await new Promise(res=>{
    if(fmt==="png") c.toBlob(res,"image/png");
    else c.toBlob(res,"image/jpeg", q);
  });
}

$("btnExport").addEventListener("click", async ()=>{
  if(!S.work.front || !S.work.back) return alert("Front & Back m√ºssen bereit sein (entzerrt oder raw).");
  buildCells();
  if(!S.cells.length) return alert("Grid ergibt keine Zellen.");

  const fmt=$("fmt").value;
  const q=parseInt($("jpgq").value,10)/100;
  const doPairs=$("pairs").checked;

  const zip=new JSZip();
  const F=zip.folder("front");
  const B=zip.folder("back");
  const P=doPairs ? zip.folder("pairs") : null;

  setStatus("Export l√§uft‚Ä¶");

  let exported=0;
  for(const cell of S.cells){
    if(S.disabledCells.has(cell.idx)) continue;

    const f=tightOrFull(cropCanvas(S.work.front, cell));
    const b=tightOrFull(cropCanvas(S.work.back, cell));

    F.file(`front_${pad3(cell.idx)}.${fmt}`, await canvasToBlob(f, fmt, q));
    B.file(`back_${pad3(cell.idx)}.${fmt}`,  await canvasToBlob(b, fmt, q));

    if(doPairs){
      const pair = buildPairCanvas(f,b);
      P.file(`pair_${pad3(cell.idx)}.jpg`, await canvasToBlob(pair, "jpg", q));
    }

    exported++;
    if(exported % 5 === 0) setStatus(`Export‚Ä¶ ${exported} Zellen‚Ä¶`);
  }

  const outBlob = await zip.generateAsync({type:"blob"});
  downloadBlob(outBlob, "buttongridtool_export.zip");
  setStatus(`Fertig. Exportiert: ${exported} Zellen (deaktiviert: ${S.disabledCells.size}).`);
});

/* start grid hooks */
hookGridCanvas();
</script>
</body>
</html>
