<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>ButtonGridTool ‚Äì iPhone Wizard</title>
  <style>
    :root { --pad: 12px; --gap: 10px; --b: #2b6cff; }
    body { font-family: -apple-system, system-ui, Segoe UI, Roboto, Arial; margin:0; background:#f5f6f8; }
    header { background:#fff; border-bottom:1px solid #ddd; padding:10px 12px; position:sticky; top:0; z-index:10; display:flex; align-items:center; justify-content:space-between; gap:10px;}
    header h1 { font-size:16px; margin:0; }
    header .hdrBtns { display:flex; gap:10px; align-items:center; }
    button, select, input[type="number"], input[type="range"] {
      font-size:16px; padding:10px 12px; border-radius:10px; border:1px solid #bbb; background:#fff;
    }
    button.primary { background: var(--b); color:#fff; border-color: var(--b); }
    button:disabled { opacity:.5; }
    main { padding: var(--pad); max-width: 980px; margin:0 auto; }
    .card { background:#fff; border:1px solid #ddd; border-radius:10px; padding:12px; margin:10px 0; }
    .row { display:flex; flex-wrap:wrap; gap: var(--gap); align-items:center; }
    .pill { display:inline-flex; gap:8px; align-items:center; padding:8px 10px; border:1px solid #ddd; border-radius:999px; }
    canvas { width:100%; height:auto; border:1px solid #ddd; border-radius:10px; background:#000; touch-action: none; }
    .small { color:#666; font-size:13px; line-height:1.35; }
    .split { display:grid; grid-template-columns: 1fr 1fr; gap:10px; }
    @media (max-width:720px){ .split { grid-template-columns: 1fr; } }
    .stepTitle { font-weight:700; margin:0 0 8px 0; display:flex; align-items:center; justify-content:space-between; gap:10px;}
    .badge { font-size:12px; padding:4px 8px; border-radius:999px; border:1px solid #ddd; color:#333; background:#fafafa;}
    .ok { border-color:#7bd88f; background:#eaffef; }
    .warn { border-color:#ffd37b; background:#fff5e6; }

    /* Settings modal */
    .modalBackdrop {
      position:fixed; inset:0; background:rgba(0,0,0,.35);
      display:none; align-items:flex-end; justify-content:center; z-index:999;
      padding:12px;
    }
    .modal {
      width:min(980px, 100%);
      background:#fff; border-radius:16px; border:1px solid #ddd;
      padding:12px; max-height:80vh; overflow:auto;
    }
    .modalHeader { display:flex; align-items:center; justify-content:space-between; gap:10px; }
    .modalHeader h2 { margin:0; font-size:16px; }
    .hr { height:1px; background:#eee; margin:10px 0; }
    .muted { color:#777; font-size:13px; }
  </style>
</head>
<body>
<header>
  <h1>ButtonGridTool ‚Äì iPhone Wizard</h1>
  <div class="hdrBtns">
    <button id="btnGear" title="Einstellungen">‚öôÔ∏è</button>
  </div>
</header>

<main>

  <!-- STEP 1 FRONT -->
  <div class="card">
    <div class="stepTitle">
      <span>Step 1 ‚Äì Front</span>
      <span id="frontState" class="badge warn">nicht geladen</span>
    </div>

    <!-- hidden inputs: one forces camera, one opens picker -->
    <input id="frontCam" type="file" accept="image/*" capture="environment" hidden />
    <input id="frontPick" type="file" accept="image/*" hidden />

    <div class="row">
      <button id="btnFrontCam" class="primary">üì∑ Foto machen</button>
      <button id="btnFrontPick">üìÅ Datei benutzen</button>
      <button id="btnFrontManual" disabled>Manuell 4 Ecken</button>
      <button id="btnFrontWarp" class="primary" disabled>Entzerren (A4)</button>
    </div>

    <canvas id="frontCanvas" width="1200" height="900"></canvas>
    <p class="small">
      Manual: 4 Ecken antippen (TL ‚Üí TR ‚Üí BR ‚Üí BL). Danach kannst du Punkte ziehen. ‚ÄûEntzerren‚Äú rechnet erst dann (stabil am iPhone).
    </p>
  </div>

  <!-- STEP 2 BACK -->
  <div class="card">
    <div class="stepTitle">
      <span>Step 2 ‚Äì Back</span>
      <span id="backState" class="badge warn">nicht geladen</span>
    </div>

    <input id="backCam" type="file" accept="image/*" capture="environment" hidden />
    <input id="backPick" type="file" accept="image/*" hidden />

    <div class="row">
      <button id="btnBackCam" class="primary" disabled>üì∑ Foto machen</button>
      <button id="btnBackPick" disabled>üìÅ Datei benutzen</button>
      <button id="btnBackManual" disabled>Manuell 4 Ecken</button>
      <button id="btnBackWarp" class="primary" disabled>Entzerren (A4)</button>
    </div>

    <canvas id="backCanvas" width="1200" height="900"></canvas>
  </div>

  <!-- STEP 3 GRID -->
  <div class="card">
    <div class="stepTitle">
      <span>Step 3 ‚Äì Grid definieren</span>
      <span id="gridState" class="badge warn">wartet auf Front</span>
    </div>

    <div class="row">
      <span class="pill"><b>Mode</b>
        <select id="gridMode">
          <option value="V" selected>Vertikal</option>
          <option value="H">Horizontal</option>
        </select>
      </span>
      <button id="btnGridClear" disabled>Grid Reset</button>
      <button id="btnGridSave" disabled>Grid speichern</button>
      <input id="gridLoad" type="file" accept="application/json" hidden />
      <button id="btnGridLoad" disabled>Grid laden</button>
      <button id="btnGridApply" class="primary" disabled>Grid anwenden</button>
    </div>

    <canvas id="gridCanvas" width="1200" height="900"></canvas>
    <p class="small">
      Tap = Linie setzen. Long-Press nahe Linie = l√∂schen. Nummern sind gro√ü/blau nur im Preview.<br>
      Grid-Pad (‚öôÔ∏è) schneidet innen je Zelle etwas weg (gegen Rand/Line).
    </p>
  </div>

  <!-- STEP 4 PREVIEW -->
  <div class="card">
    <div class="stepTitle">
      <span>Step 4 ‚Äì Preview</span>
      <span id="prevState" class="badge warn">wartet auf Grid</span>
    </div>

    <div class="row">
      <span class="pill"><b>Knopf #</b>
        <input id="idx" type="number" value="1" min="1" step="1" style="width:90px;">
      </span>
      <button id="btnPreview" class="primary" disabled>Preview aktualisieren</button>
    </div>

    <div class="split">
      <div>
        <p class="small"><b>Front Preview</b></p>
        <canvas id="knobFront" width="900" height="450"></canvas>
      </div>
      <div>
        <p class="small"><b>Back Preview</b></p>
        <canvas id="knobBack" width="900" height="450"></canvas>
      </div>
    </div>
  </div>

  <!-- STEP 5 EXPORT -->
  <div class="card">
    <div class="stepTitle">
      <span>Step 5 ‚Äì Export</span>
      <span id="expState" class="badge warn">wartet</span>
    </div>
    <div class="row">
      <button id="btnExport" class="primary" disabled>ZIP Export</button>
    </div>
    <p id="status" class="small">Status: bereit. (OpenCV.js l√§dt‚Ä¶)</p>
  </div>

</main>

<!-- SETTINGS MODAL -->
<div id="settingsBackdrop" class="modalBackdrop">
  <div class="modal">
    <div class="modalHeader">
      <h2>‚öôÔ∏è Einstellungen</h2>
      <button id="btnSettingsClose">Schlie√üen</button>
    </div>
    <p class="muted">Hier ist alles, was du nicht dauernd sehen willst. üòâ</p>
    <div class="hr"></div>

    <div class="row">
      <span class="pill"><b>Export</b>
        <select id="fmt">
          <option value="jpg" selected>JPG</option>
          <option value="png">PNG</option>
        </select>
      </span>

      <span class="pill"><b>JPG Qualit√§t</b>
        <input id="jpgq" type="range" min="50" max="100" value="92" />
        <span id="jpgqLabel">92</span>
      </span>

      <span class="pill"><b>Pairs</b>
        <input id="pairs" type="checkbox" checked />
      </span>
    </div>

    <div class="row" style="margin-top:10px;">
      <span class="pill"><b>Tight</b>
        <input id="tight" type="checkbox" checked />
      </span>

      <span class="pill"><b>Tight-Pad</b>
        <input id="tightPad" type="number" value="12" min="0" max="200" step="1" style="width:90px;">
      </span>

      <span class="pill"><b>Min-Ratio</b>
        <input id="minRatio" type="number" value="0.005" min="0.0001" max="0.5" step="0.001" style="width:110px;">
      </span>

      <span class="pill"><b>Safety Keep</b>
        <input id="keep" type="number" value="0.05" min="0.0" max="1.0" step="0.01" style="width:90px;">
      </span>

      <span class="pill"><b>Grid-Pad</b>
        <input id="gridPad" type="number" value="15" min="0" max="300" step="1" style="width:90px;">
      </span>
    </div>

    <p class="small" style="margin-top:10px;">
      Flow: Front ‚Üí Back ‚Üí Grid ‚Üí Preview ‚Üí Export. <br>
      Tipp: iPhone ‚Äû1x‚Äú und so parallel wie m√∂glich zum Blatt.
    </p>
  </div>
</div>

<!-- libs -->
<script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
<script async src="https://docs.opencv.org/4.x/opencv.js"></script>

<script>
/* ----------------- Helpers ----------------- */
const $ = (id)=>document.getElementById(id);
const statusEl = $("status");
function setStatus(s){ statusEl.textContent = "Status: " + s; }

function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }

function drawFit(canvas, imgBitmap){
  const ctx = canvas.getContext("2d");
  const cw=canvas.width, ch=canvas.height;
  ctx.setTransform(1,0,0,1,0,0);
  ctx.clearRect(0,0,cw,ch);
  const r = Math.min(cw/imgBitmap.width, ch/imgBitmap.height);
  const w = imgBitmap.width*r, h = imgBitmap.height*r;
  const x = (cw-w)/2, y=(ch-h)/2;
  ctx.drawImage(imgBitmap, x,y,w,h);
  return {x,y,w,h,r};
}

function downloadBlob(blob, filename){
  const a = document.createElement("a");
  a.href = URL.createObjectURL(blob);
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  a.remove();
  setTimeout(()=>URL.revokeObjectURL(a.href), 1000);
}

/* ----------------- Settings modal ----------------- */
$("btnGear").addEventListener("click", ()=>{
  $("settingsBackdrop").style.display = "flex";
});
$("btnSettingsClose").addEventListener("click", ()=>{
  $("settingsBackdrop").style.display = "none";
});
$("settingsBackdrop").addEventListener("click", (e)=>{
  if(e.target === $("settingsBackdrop")) $("settingsBackdrop").style.display = "none";
});
$("jpgq").addEventListener("input", ()=> $("jpgqLabel").textContent = $("jpgq").value);

/* ----------------- State ----------------- */
const S = {
  cvReady: false,

  frontBmp: null,
  backBmp: null,

  frontCorners: [], // view coords (canvas space)
  backCorners: [],

  frontWarp: null,  // OffscreenCanvas A4
  backWarp: null,

  dragging: null,   // {which, idx} or null

  xLines: [],
  yLines: [],
  cells: [],
};

const A4_W = 2480;
const A4_H = 3508;

/* ----------------- OpenCV ready ----------------- */
let cvWaitTimer = setInterval(()=>{
  if(window.cv && cv.Mat){
    clearInterval(cvWaitTimer);
    S.cvReady = true;
    setStatus("bereit. OpenCV.js ist geladen.");
  }
}, 200);

/* ----------------- File pickers (camera vs file) ----------------- */
$("btnFrontCam").addEventListener("click", ()=> $("frontCam").click());
$("btnFrontPick").addEventListener("click", ()=> $("frontPick").click());

$("btnBackCam").addEventListener("click", ()=> $("backCam").click());
$("btnBackPick").addEventListener("click", ()=> $("backPick").click());

$("frontCam").addEventListener("change", (e)=> loadImageFromInput(e, "front"));
$("frontPick").addEventListener("change", (e)=> loadImageFromInput(e, "front"));
$("backCam").addEventListener("change", (e)=> loadImageFromInput(e, "back"));
$("backPick").addEventListener("change", (e)=> loadImageFromInput(e, "back"));

async function loadImageFromInput(e, which){
  const f = e.target.files?.[0];
  if(!f) return;

  const bmp = await createImageBitmap(f);
  if(which==="front"){
    S.frontBmp = bmp;
    $("frontState").textContent = "geladen";
    $("frontState").className = "badge ok";
    renderFront();
    $("btnFrontManual").disabled = false;
    $("btnFrontWarp").disabled = true;
    setStatus("Front geladen. Jetzt Manuell 4 Ecken und dann Entzerren.");
    // enable back step buttons now
    $("btnBackCam").disabled = false;
    $("btnBackPick").disabled = false;
  }else{
    S.backBmp = bmp;
    $("backState").textContent = "geladen";
    $("backState").className = "badge ok";
    renderBack();
    $("btnBackManual").disabled = false;
    $("btnBackWarp").disabled = true;
    setStatus("Back geladen. Jetzt Manuell 4 Ecken und dann Entzerren.");
  }
}

/* ----------------- Manual corners UI ----------------- */
$("btnFrontManual").addEventListener("click", ()=> startManual("front"));
$("btnBackManual").addEventListener("click", ()=> startManual("back"));
$("btnFrontWarp").addEventListener("click", ()=> warpA4("front"));
$("btnBackWarp").addEventListener("click", ()=> warpA4("back"));

function renderFront(){
  if(!S.frontBmp) return;
  const c=$("frontCanvas");
  drawFit(c, S.frontBmp);
  drawCorners("front");
}
function renderBack(){
  if(!S.backBmp) return;
  const c=$("backCanvas");
  drawFit(c, S.backBmp);
  drawCorners("back");
}

function startManual(which){
  const canvas = which==="front" ? $("frontCanvas") : $("backCanvas");
  const bmp = which==="front" ? S.frontBmp : S.backBmp;
  if(!bmp) return;

  const fit = drawFit(canvas, bmp);
  const pad = 18;
  const corners = [
    {x:fit.x+pad,       y:fit.y+pad},         // TL
    {x:fit.x+fit.w-pad, y:fit.y+pad},         // TR
    {x:fit.x+fit.w-pad, y:fit.y+fit.h-pad},   // BR
    {x:fit.x+pad,       y:fit.y+fit.h-pad},   // BL
  ];

  if(which==="front") S.frontCorners = corners;
  else S.backCorners = corners;

  hookCornerEvents(canvas, which);
  drawFit(canvas, bmp);
  drawCorners(which);

  if(which==="front") $("btnFrontWarp").disabled = false;
  else $("btnBackWarp").disabled = false;

  setStatus(`${which.toUpperCase()}: Ecken setzen/ziehen. Dann Entzerren.`);
}

function drawCorners(which){
  const canvas = which==="front" ? $("frontCanvas") : $("backCanvas");
  const bmp = which==="front" ? S.frontBmp : S.backBmp;
  const pts = which==="front" ? S.frontCorners : S.backCorners;
  if(!bmp || !pts || pts.length!==4) return;

  const ctx=canvas.getContext("2d");
  ctx.save();
  ctx.lineWidth=3;
  ctx.strokeStyle="lime";
  ctx.fillStyle="lime";
  ctx.font="22px -apple-system";
  ctx.beginPath();
  ctx.moveTo(pts[0].x, pts[0].y);
  for(let i=1;i<4;i++) ctx.lineTo(pts[i].x, pts[i].y);
  ctx.closePath(); ctx.stroke();
  pts.forEach((p,i)=>{
    ctx.beginPath(); ctx.arc(p.x,p.y,10,0,Math.PI*2); ctx.fill();
    ctx.fillText(String(i+1), p.x+14, p.y-14);
  });
  ctx.restore();
}

function hookCornerEvents(canvas, which){
  canvas.onpointerdown = (e)=>{
    const pts = which==="front" ? S.frontCorners : S.backCorners;
    if(!pts || pts.length!==4) return;
    canvas.setPointerCapture(e.pointerId);

    const p = toLocal(canvas, e);
    // pick nearest corner
    let best=-1, bd=1e9;
    for(let i=0;i<4;i++){
      const d = Math.hypot(pts[i].x-p.x, pts[i].y-p.y);
      if(d<bd){ bd=d; best=i; }
    }
    if(bd < 45){
      S.dragging = {which, idx:best};
    } else {
      // tap-to-set in order if user wants: find first corner that is "unset"
      // (we treat all set by default; so this is just convenience)
    }
  };

  canvas.onpointermove = (e)=>{
    if(!S.dragging || S.dragging.which!==which) return;
    const pts = which==="front" ? S.frontCorners : S.backCorners;
    const bmp = which==="front" ? S.frontBmp : S.backBmp;
    if(!pts || !bmp) return;

    const p = toLocal(canvas, e);
    pts[S.dragging.idx].x = clamp(p.x, 0, canvas.width);
    pts[S.dragging.idx].y = clamp(p.y, 0, canvas.height);

    // redraw base image + corners
    drawFit(canvas, bmp);
    drawCorners(which);
  };

  canvas.onpointerup = (e)=>{
    S.dragging = null;
  };
}

function toLocal(canvas, e){
  const r = canvas.getBoundingClientRect();
  const x = (e.clientX - r.left) * (canvas.width / r.width);
  const y = (e.clientY - r.top)  * (canvas.height/ r.height);
  return {x,y};
}

/* ----------------- Warp (OpenCV.js) ----------------- */
async function warpA4(which){
  if(!S.cvReady) return alert("OpenCV.js l√§dt noch. 1‚Äì2 Sekunden.");
  const bmp = which==="front" ? S.frontBmp : S.backBmp;
  const canvas = which==="front" ? $("frontCanvas") : $("backCanvas");
  const ptsView = which==="front" ? S.frontCorners : S.backCorners;
  if(!bmp || !ptsView || ptsView.length!==4) return alert("Bitte zuerst Manuell 4 Ecken.");

  setStatus(`${which.toUpperCase()}: Entzerren l√§uft‚Ä¶`);

  // map view points -> image pixels
  const fit = drawFit(canvas, bmp);
  const srcPts = ptsView.map(p=>{
    const vx = clamp(p.x, fit.x, fit.x+fit.w);
    const vy = clamp(p.y, fit.y, fit.y+fit.h);
    return { x: (vx - fit.x)/fit.r, y: (vy - fit.y)/fit.r };
  });

  // build OpenCV mats
  const src = cv.imread(bitmapToCanvas(bmp));
  const dsize = new cv.Size(A4_W, A4_H);

  const srcTri = cv.matFromArray(4, 1, cv.CV_32FC2, [
    srcPts[0].x, srcPts[0].y,
    srcPts[1].x, srcPts[1].y,
    srcPts[2].x, srcPts[2].y,
    srcPts[3].x, srcPts[3].y
  ]);
  const dstTri = cv.matFromArray(4, 1, cv.CV_32FC2, [
    0, 0,
    A4_W, 0,
    A4_W, A4_H,
    0, A4_H
  ]);

  const M = cv.getPerspectiveTransform(srcTri, dstTri);
  const dst = new cv.Mat();
  cv.warpPerspective(src, dst, M, dsize, cv.INTER_LINEAR, cv.BORDER_CONSTANT, new cv.Scalar(255,255,255,255));

  // convert to OffscreenCanvas
  const out = new OffscreenCanvas(A4_W, A4_H);
  cv.imshow(out, dst);

  // cleanup
  src.delete(); dst.delete(); M.delete(); srcTri.delete(); dstTri.delete();

  if(which==="front"){
    S.frontWarp = out;
    $("gridState").textContent = "Front ok ‚Üí Grid m√∂glich";
    $("gridState").className = "badge ok";
    // enable grid tools
    $("btnGridClear").disabled = false;
    $("btnGridSave").disabled = false;
    $("btnGridLoad").disabled = false;
    $("btnGridApply").disabled = false;
    renderGrid();
    setStatus("Front entzerrt. Jetzt Back entzerren oder direkt Grid setzen.");
  } else {
    S.backWarp = out;
    $("backState").textContent = "entzerrt";
    $("backState").className = "badge ok";
    setStatus("Back entzerrt. Jetzt Grid/Preview/Export.");
  }

  // mark state badges
  if(which==="front"){
    $("frontState").textContent = "entzerrt";
    $("frontState").className = "badge ok";
  }
}

/* helper: convert bitmap to canvas for cv.imread */
function bitmapToCanvas(bmp){
  const c = document.createElement("canvas");
  c.width = bmp.width; c.height = bmp.height;
  c.getContext("2d").drawImage(bmp,0,0);
  return c;
}

/* ----------------- Grid rendering + interaction ----------------- */
$("btnGridClear").addEventListener("click", ()=>{
  S.xLines=[]; S.yLines=[];
  renderGrid();
  setStatus("Grid reset.");
});
$("btnGridSave").addEventListener("click", ()=>{
  if(!S.frontWarp) return alert("Erst Front entzerren.");
  const data = { version: 1,
    x_rel: S.xLines.map(x=>x/A4_W).sort((a,b)=>a-b),
    y_rel: S.yLines.map(y=>y/A4_H).sort((a,b)=>a-b)
  };
  downloadBlob(new Blob([JSON.stringify(data,null,2)], {type:"application/json"}), "grid.json");
});
$("btnGridLoad").addEventListener("click", ()=> $("gridLoad").click());
$("gridLoad").addEventListener("change", async (e)=>{
  const f=e.target.files?.[0]; if(!f) return;
  const j = JSON.parse(await f.text());
  S.xLines=(j.x_rel||[]).map(r=>Math.round(r*A4_W));
  S.yLines=(j.y_rel||[]).map(r=>Math.round(r*A4_H));
  renderGrid();
  setStatus("Grid geladen.");
});

$("btnGridApply").addEventListener("click", ()=>{
  if(!S.frontWarp) return;
  buildCells();
  $("btnPreview").disabled = (S.cells.length===0);
  $("btnExport").disabled = (S.cells.length===0 || !S.backWarp); // Back ist Pflicht
  $("prevState").textContent = S.cells.length ? "bereit" : "wartet";
  $("prevState").className = S.cells.length ? "badge ok" : "badge warn";
  $("expState").textContent = (!S.backWarp) ? "wartet auf Back" : (S.cells.length ? "bereit" : "wartet");
  $("expState").className = (S.backWarp && S.cells.length) ? "badge ok" : "badge warn";
  setStatus(`Grid angewandt: ${S.cells.length} Zellen.`);
});

function renderGrid(){
  const c=$("gridCanvas");
  const ctx=c.getContext("2d");
  ctx.setTransform(1,0,0,1,0,0);
  ctx.clearRect(0,0,c.width,c.height);

  if(!S.frontWarp){
    ctx.fillStyle="#222"; ctx.fillRect(0,0,c.width,c.height);
    ctx.fillStyle="#fff"; ctx.font="24px -apple-system";
    ctx.fillText("Erst Front entzerren.", 20, 50);
    return;
  }

  // draw warp fitted
  const iw=A4_W, ih=A4_H;
  const rr = Math.min(c.width/iw, c.height/ih);
  const w=iw*rr, h=ih*rr;
  const ox=(c.width-w)/2, oy=(c.height-h)/2;
  ctx.drawImage(S.frontWarp, ox, oy, w, h);

  // overlay lines & numbers
  const xs=[0,...S.xLines.sort((a,b)=>a-b),A4_W];
  const ys=[0,...S.yLines.sort((a,b)=>a-b),A4_H];

  ctx.save();
  ctx.lineWidth=2;
  ctx.strokeStyle="rgba(0,120,255,0.9)";
  ctx.fillStyle="rgba(0,120,255,0.9)";
  ctx.font="48px -apple-system";

  for(const xv of xs){
    const X = ox + xv*rr;
    ctx.beginPath(); ctx.moveTo(X, oy); ctx.lineTo(X, oy+h); ctx.stroke();
  }
  for(const yv of ys){
    const Y = oy + yv*rr;
    ctx.beginPath(); ctx.moveTo(ox, Y); ctx.lineTo(ox+w, Y); ctx.stroke();
  }

  let idx=1;
  for(let r=0;r<ys.length-1;r++){
    for(let c2=0;c2<xs.length-1;c2++){
      const tx=ox + xs[c2]*rr + 12;
      const ty=oy + ys[r]*rr + 52;
      ctx.fillText(String(idx), tx, ty);
      idx++;
    }
  }
  ctx.restore();

  $("gridState").textContent = "Grid editierbar";
  $("gridState").className = "badge ok";
}

/* tap add line, long-press delete */
let longPressTimer=null;
$("gridCanvas").addEventListener("pointerdown",(e)=>{
  if(!S.frontWarp) return;
  const c=$("gridCanvas");
  c.setPointerCapture(e.pointerId);
  const p = localPoint(c,e);

  longPressTimer=setTimeout(()=>{ deleteNearestGridLine(p.x,p.y); }, 450);
});
$("gridCanvas").addEventListener("pointerup",(e)=>{
  if(!S.frontWarp) return;
  clearTimeout(longPressTimer);
  longPressTimer=null;

  const c=$("gridCanvas");
  const p = localPoint(c,e);
  addGridLineFromView(p.x,p.y);
});

function localPoint(canvas,e){
  const r=canvas.getBoundingClientRect();
  return {
    x:(e.clientX-r.left)*(canvas.width/r.width),
    y:(e.clientY-r.top)*(canvas.height/r.height)
  };
}
function viewToA4(x,y){
  const c=$("gridCanvas");
  const iw=A4_W, ih=A4_H;
  const rr = Math.min(c.width/iw, c.height/ih);
  const w=iw*rr, h=ih*rr;
  const ox=(c.width-w)/2, oy=(c.height-h)/2;
  const ax = (x-ox)/rr;
  const ay = (y-oy)/rr;
  return {ax,ay};
}
function addGridLineFromView(x,y){
  const {ax,ay}=viewToA4(x,y);
  const mode=$("gridMode").value;
  if(mode==="V"){
    S.xLines.push(Math.round(clamp(ax,1,A4_W-1)));
    S.xLines=[...new Set(S.xLines)].sort((a,b)=>a-b);
  }else{
    S.yLines.push(Math.round(clamp(ay,1,A4_H-1)));
    S.yLines=[...new Set(S.yLines)].sort((a,b)=>a-b);
  }
  renderGrid();
}
function deleteNearestGridLine(x,y){
  const {ax,ay}=viewToA4(x,y);
  const thr=12;
  let best=null;
  for(let i=0;i<S.xLines.length;i++){
    const d=Math.abs(S.xLines[i]-ax);
    if(best===null || d<best.d) best={kind:"x",i,d};
  }
  for(let i=0;i<S.yLines.length;i++){
    const d=Math.abs(S.yLines[i]-ay);
    if(best===null || d<best.d) best={kind:"y",i,d};
  }
  if(!best || best.d>thr) return;
  if(best.kind==="x") S.xLines.splice(best.i,1);
  else S.yLines.splice(best.i,1);
  renderGrid();
}

/* ----------------- Cells + Tight crop ----------------- */
function buildCells(){
  const pad = parseInt($("gridPad").value||"0",10);
  const xs=[0,...S.xLines,A4_W].map(v=>Math.round(v)).sort((a,b)=>a-b);
  const ys=[0,...S.yLines,A4_H].map(v=>Math.round(v)).sort((a,b)=>a-b);

  const cells=[];
  for(let r=0;r<ys.length-1;r++){
    for(let c=0;c<xs.length-1;c++){
      let x0=xs[c]+pad, x1=xs[c+1]-pad;
      let y0=ys[r]+pad, y1=ys[r+1]-pad;
      x0=clamp(x0,0,A4_W); x1=clamp(x1,0,A4_W);
      y0=clamp(y0,0,A4_H); y1=clamp(y1,0,A4_H);
      if(x1-x0>5 && y1-y0>5) cells.push({x0,y0,x1,y1});
    }
  }
  S.cells=cells;
}

function getCellImage(offscreenCanvas, cell){
  const w=cell.x1-cell.x0, h=cell.y1-cell.y0;
  const c=new OffscreenCanvas(w,h);
  c.getContext("2d").drawImage(offscreenCanvas, cell.x0,cell.y0,w,h, 0,0,w,h);
  return c;
}

function safeTightOrFull(cellCanvas){
  const tight = $("tight").checked;
  if(!tight) return cellCanvas;

  const pad = parseInt($("tightPad").value||"0",10);
  const minRatio = parseFloat($("minRatio").value||"0.005");
  const keep = parseFloat($("keep").value||"0.05");

  const w=cellCanvas.width, h=cellCanvas.height;
  const ctx=cellCanvas.getContext("2d",{willReadFrequently:true});
  const img=ctx.getImageData(0,0,w,h);

  let minX=w, minY=h, maxX=0, maxY=0, count=0;
  const thr=245;
  for(let y=0;y<h;y++){
    for(let x=0;x<w;x++){
      const i=(y*w+x)*4;
      const r=img.data[i], g=img.data[i+1], b=img.data[i+2];
      const isFg = (r<thr || g<thr || b<thr);
      if(isFg){
        count++;
        if(x<minX) minX=x;
        if(y<minY) minY=y;
        if(x>maxX) maxX=x;
        if(y>maxY) maxY=y;
      }
    }
  }

  const ratio = count/(w*h);
  if(ratio < minRatio) return cellCanvas;

  minX=clamp(minX-pad,0,w-1);
  minY=clamp(minY-pad,0,h-1);
  maxX=clamp(maxX+pad,0,w-1);
  maxY=clamp(maxY+pad,0,h-1);

  const cw=maxX-minX+1, ch=maxY-minY+1;
  if((cw/w)<keep || (ch/h)<keep) return cellCanvas;

  const out=new OffscreenCanvas(cw,ch);
  out.getContext("2d").drawImage(cellCanvas, minX,minY,cw,ch, 0,0,cw,ch);
  return out;
}

function drawCanvasTo(canvas, offscreenCanvas){
  const ctx=canvas.getContext("2d");
  ctx.setTransform(1,0,0,1,0,0);
  ctx.clearRect(0,0,canvas.width,canvas.height);
  const r = Math.min(canvas.width/offscreenCanvas.width, canvas.height/offscreenCanvas.height);
  const w = offscreenCanvas.width*r, h = offscreenCanvas.height*r;
  const x=(canvas.width-w)/2, y=(canvas.height-h)/2;
  ctx.drawImage(offscreenCanvas, x,y,w,h);
}

$("btnPreview").addEventListener("click", ()=> updateKnobPreview());

function updateKnobPreview(){
  if(!S.frontWarp) return alert("Erst Front entzerren.");
  if(!S.backWarp) return alert("Back ist Pflicht: bitte Back entzerren.");
  buildCells();
  if(!S.cells.length) return alert("Grid ergibt keine Zellen.");

  const idx = clamp(parseInt($("idx").value||"1",10), 1, S.cells.length);
  $("idx").value = idx;

  const cell = S.cells[idx-1];

  const fCell = getCellImage(S.frontWarp, cell);
  const fCrop = safeTightOrFull(fCell);
  drawCanvasTo($("knobFront"), fCrop);

  const bCell = getCellImage(S.backWarp, cell);
  const bCrop = safeTightOrFull(bCell);
  drawCanvasTo($("knobBack"), bCrop);

  $("prevState").textContent = "bereit";
  $("prevState").className = "badge ok";
  $("btnExport").disabled = false;
  setStatus("Preview aktualisiert.");
}

/* ----------------- Export ZIP ----------------- */
async function canvasToBlob(offscreenCanvas, fmt, jpgq){
  return await new Promise(res=>{
    const c=document.createElement("canvas");
    c.width=offscreenCanvas.width; c.height=offscreenCanvas.height;
    c.getContext("2d").drawImage(offscreenCanvas,0,0);
    if(fmt==="png") c.toBlob(res,"image/png");
    else c.toBlob(res,"image/jpeg", jpgq);
  });
}

$("btnExport").addEventListener("click", ()=> exportZip());

async function exportZip(){
  if(!S.frontWarp || !S.backWarp) return alert("Front & Back m√ºssen entzerrt sein.");
  buildCells();
  if(!S.cells.length) return alert("Grid ergibt keine Zellen.");

  const fmt = $("fmt").value;
  const jpgq = parseInt($("jpgq").value,10)/100;
  const doPairs = $("pairs").checked;

  const zip = new JSZip();
  const frontFolder = zip.folder("front");
  const backFolder  = zip.folder("back");
  const pairFolder  = doPairs ? zip.folder("pairs") : null;

  setStatus("Export l√§uft‚Ä¶");

  for(let i=0;i<S.cells.length;i++){
    const cell = S.cells[i];

    const fCell = getCellImage(S.frontWarp, cell);
    const fCrop = safeTightOrFull(fCell);
    const fBlob = await canvasToBlob(fCrop, fmt, jpgq);
    frontFolder.file(`front_${String(i+1).padStart(3,"0")}.${fmt}`, fBlob);

    const bCell = getCellImage(S.backWarp, cell);
    const bCrop = safeTightOrFull(bCell);
    const bBlob = await canvasToBlob(bCrop, fmt, jpgq);
    backFolder.file(`back_${String(i+1).padStart(3,"0")}.${fmt}`, bBlob);

    if(doPairs){
      const pair = new OffscreenCanvas(fCrop.width + bCrop.width, Math.max(fCrop.height, bCrop.height));
      const pctx = pair.getContext("2d");
      pctx.fillStyle="#fff"; pctx.fillRect(0,0,pair.width,pair.height);
      pctx.drawImage(fCrop, 0, 0);
      pctx.drawImage(bCrop, fCrop.width, 0);
      const pBlob = await canvasToBlob(pair, "jpg", jpgq);
      pairFolder.file(`pair_${String(i+1).padStart(3,"0")}.jpg`, pBlob);
    }

    if((i+1)%5===0) setStatus(`Export‚Ä¶ ${i+1}/${S.cells.length}`);
  }

  const outBlob = await zip.generateAsync({type:"blob"});
  downloadBlob(outBlob, "buttongridtool_export.zip");
  setStatus("Fertig. ZIP geladen.");
  $("expState").textContent = "fertig";
  $("expState").className = "badge ok";
}
</script>
</body>
</html>