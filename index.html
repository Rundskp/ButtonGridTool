<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>ButtonGridTool ‚Äì iPhone Wizard</title>
  <style>
    :root { --pad: 12px; --gap: 10px; --b: #2b6cff; }
    body { font-family: -apple-system, system-ui, Segoe UI, Roboto, Arial; margin:0; background:#f5f6f8; }
    header { background:#fff; border-bottom:1px solid #ddd; padding:10px 12px; position:sticky; top:0; z-index:10; display:flex; align-items:center; justify-content:space-between; gap:10px;}
    header h1 { font-size:16px; margin:0; }
    header .hdrBtns { display:flex; gap:10px; align-items:center; }
    button, select, input[type="number"], input[type="range"] {
      font-size:16px; padding:10px 12px; border-radius:10px; border:1px solid #bbb; background:#fff;
    }
    button.primary { background: var(--b); color:#fff; border-color: var(--b); }
    button:disabled { opacity:.5; }
    main { padding: var(--pad); max-width: 980px; margin:0 auto; }
    .card { background:#fff; border:1px solid #ddd; border-radius:10px; padding:12px; margin:10px 0; }
    .row { display:flex; flex-wrap:wrap; gap: var(--gap); align-items:center; }
    .pill { display:inline-flex; gap:8px; align-items:center; padding:8px 10px; border:1px solid #ddd; border-radius:999px; }
    canvas { width:100%; height:auto; border:1px solid #ddd; border-radius:10px; background:#000; touch-action:none; }
    .small { color:#666; font-size:13px; line-height:1.35; }
    .split { display:grid; grid-template-columns: 1fr 1fr; gap:10px; }
    @media (max-width:720px){ .split { grid-template-columns: 1fr; } }
    .stepTitle { font-weight:700; margin:0 0 8px 0; display:flex; align-items:center; justify-content:space-between; gap:10px;}
    .badge { font-size:12px; padding:4px 8px; border-radius:999px; border:1px solid #ddd; color:#333; background:#fafafa;}
    .ok { border-color:#7bd88f; background:#eaffef; }
    .warn { border-color:#ffd37b; background:#fff5e6; }

    .modalBackdrop { position:fixed; inset:0; background:rgba(0,0,0,.35);
      display:none; align-items:flex-end; justify-content:center; z-index:999; padding:12px;}
    .modal { width:min(980px, 100%); background:#fff; border-radius:16px; border:1px solid #ddd;
      padding:12px; max-height:80vh; overflow:auto;}
    .modalHeader { display:flex; align-items:center; justify-content:space-between; gap:10px; }
    .modalHeader h2 { margin:0; font-size:16px; }
    .hr { height:1px; background:#eee; margin:10px 0; }
    .muted { color:#777; font-size:13px; }

    /* tiny tool buttons */
    .toolbtn { padding:10px 12px; }
  </style>
</head>
<body>
<header>
  <h1>ButtonGridTool ‚Äì iPhone Wizard</h1>
  <div class="hdrBtns">
    <button id="btnGear" title="Einstellungen">‚öôÔ∏è</button>
  </div>
</header>

<main>

  <!-- STEP 1 FRONT -->
  <div class="card">
    <div class="stepTitle">
      <span>Step 1 ‚Äì Front</span>
      <span id="frontState" class="badge warn">nicht geladen</span>
    </div>

    <input id="frontCam" type="file" accept="image/*" capture="environment" hidden />
    <input id="frontPick" type="file" accept="image/*" hidden />

    <div class="row">
      <button id="btnFrontCam" class="primary">üì∑ Foto machen</button>
      <button id="btnFrontPick">üìÅ Datei benutzen</button>

      <button id="btnFrontManual" disabled>Manuell 4 Ecken</button>
      <button id="btnFrontWarp" class="primary" disabled>Entzerren (A4)</button>

      <button id="btnFrontZoomIn" class="toolbtn" disabled>Ôºã</button>
      <button id="btnFrontZoomOut" class="toolbtn" disabled>Ôºç</button>
      <button id="btnFrontResetView" class="toolbtn" disabled>Reset View</button>
    </div>

    <canvas id="frontCanvas" width="1200" height="900"></canvas>
    <p class="small">
      <b>Manuell 4 Ecken:</b> Tippe 4√ó ins Bild: <b>TL ‚Üí TR ‚Üí BR ‚Üí BL</b>. Danach Punkte ziehen. <br>
      <b>Zoomen/Pan:</b> Pinch-Zoom + ziehen (oder +/‚àí Buttons). Punkte bleiben fix (Bildkoordinaten).<br>
      Dann <b>Entzerren</b> dr√ºcken.
    </p>
  </div>

  <!-- STEP 2 BACK -->
  <div class="card">
    <div class="stepTitle">
      <span>Step 2 ‚Äì Back</span>
      <span id="backState" class="badge warn">nicht geladen</span>
    </div>

    <input id="backCam" type="file" accept="image/*" capture="environment" hidden />
    <input id="backPick" type="file" accept="image/*" hidden />

    <div class="row">
      <button id="btnBackCam" class="primary" disabled>üì∑ Foto machen</button>
      <button id="btnBackPick" disabled>üìÅ Datei benutzen</button>

      <button id="btnBackManual" disabled>Manuell 4 Ecken</button>
      <button id="btnBackWarp" class="primary" disabled>Entzerren (A4)</button>

      <button id="btnBackZoomIn" class="toolbtn" disabled>Ôºã</button>
      <button id="btnBackZoomOut" class="toolbtn" disabled>Ôºç</button>
      <button id="btnBackResetView" class="toolbtn" disabled>Reset View</button>
    </div>

    <canvas id="backCanvas" width="1200" height="900"></canvas>
  </div>

  <!-- STEP 3 GRID -->
  <div class="card">
    <div class="stepTitle">
      <span>Step 3 ‚Äì Grid definieren</span>
      <span id="gridState" class="badge warn">wartet auf Front</span>
    </div>

    <div class="row">
      <span class="pill"><b>Mode</b>
        <select id="gridMode">
          <option value="V" selected>Vertikal</option>
          <option value="H">Horizontal</option>
        </select>
      </span>
      <button id="btnGridClear" disabled>Grid Reset</button>
      <button id="btnGridSave" disabled>Grid speichern</button>
      <input id="gridLoad" type="file" accept="application/json" hidden />
      <button id="btnGridLoad" disabled>Grid laden</button>
      <button id="btnGridApply" class="primary" disabled>Grid anwenden</button>
    </div>

    <canvas id="gridCanvas" width="1200" height="900"></canvas>
    <p class="small">
      Tap = Linie setzen. Long-Press nahe Linie = l√∂schen. Nummern sind gro√ü/blau nur im Preview.
    </p>
  </div>

  <!-- STEP 4 PREVIEW -->
  <div class="card">
    <div class="stepTitle">
      <span>Step 4 ‚Äì Preview</span>
      <span id="prevState" class="badge warn">wartet auf Grid</span>
    </div>

    <div class="row">
      <span class="pill"><b>Knopf #</b>
        <input id="idx" type="number" value="1" min="1" step="1" style="width:90px;">
      </span>
      <button id="btnPreview" class="primary" disabled>Preview aktualisieren</button>
    </div>

    <div class="split">
      <div>
        <p class="small"><b>Front Preview</b></p>
        <canvas id="knobFront" width="900" height="450"></canvas>
      </div>
      <div>
        <p class="small"><b>Back Preview</b></p>
        <canvas id="knobBack" width="900" height="450"></canvas>
      </div>
    </div>
  </div>

  <!-- STEP 5 EXPORT -->
  <div class="card">
    <div class="stepTitle">
      <span>Step 5 ‚Äì Export</span>
      <span id="expState" class="badge warn">wartet</span>
    </div>
    <div class="row">
      <button id="btnExport" class="primary" disabled>ZIP Export</button>
    </div>
    <p id="status" class="small">Status: OpenCV.js l√§dt‚Ä¶</p>
  </div>

</main>

<!-- SETTINGS MODAL -->
<div id="settingsBackdrop" class="modalBackdrop">
  <div class="modal">
    <div class="modalHeader">
      <h2>‚öôÔ∏è Einstellungen</h2>
      <button id="btnSettingsClose">Schlie√üen</button>
    </div>
    <p class="muted">Hier ist alles, was du nicht dauernd sehen willst.</p>
    <div class="hr"></div>

    <div class="row">
      <span class="pill"><b>Export</b>
        <select id="fmt">
          <option value="jpg" selected>JPG</option>
          <option value="png">PNG</option>
        </select>
      </span>

      <span class="pill"><b>JPG Qualit√§t</b>
        <input id="jpgq" type="range" min="50" max="100" value="92" />
        <span id="jpgqLabel">92</span>
      </span>

      <span class="pill"><b>Pairs</b>
        <input id="pairs" type="checkbox" checked />
      </span>
    </div>

    <div class="row" style="margin-top:10px;">
      <span class="pill"><b>Tight</b>
        <input id="tight" type="checkbox" checked />
      </span>

      <span class="pill"><b>Tight-Pad</b>
        <input id="tightPad" type="number" value="12" min="0" max="200" step="1" style="width:90px;">
      </span>

      <span class="pill"><b>Min-Ratio</b>
        <input id="minRatio" type="number" value="0.005" min="0.0001" max="0.5" step="0.001" style="width:110px;">
      </span>

      <span class="pill"><b>Safety Keep</b>
        <input id="keep" type="number" value="0.05" min="0.0" max="1.0" step="0.01" style="width:90px;">
      </span>

      <span class="pill"><b>Grid-Pad</b>
        <input id="gridPad" type="number" value="15" min="0" max="300" step="1" style="width:90px;">
      </span>
    </div>
  </div>
</div>

<!-- hidden warp canvases (iOS-safe target for cv.imshow) -->
<canvas id="frontWarpCanvas" width="2480" height="3508" hidden></canvas>
<canvas id="backWarpCanvas" width="2480" height="3508" hidden></canvas>

<script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
<script async src="https://docs.opencv.org/4.x/opencv.js"></script>

<script>
/* ----------------- Helpers ----------------- */
const $ = (id)=>document.getElementById(id);
const statusEl = $("status");
function setStatus(s){ statusEl.textContent = "Status: " + s; }
function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
function downloadBlob(blob, filename){
  const a = document.createElement("a");
  a.href = URL.createObjectURL(blob);
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  a.remove();
  setTimeout(()=>URL.revokeObjectURL(a.href), 1000);
}

/* Settings modal */
$("btnGear").addEventListener("click", ()=> $("settingsBackdrop").style.display="flex");
$("btnSettingsClose").addEventListener("click", ()=> $("settingsBackdrop").style.display="none");
$("settingsBackdrop").addEventListener("click", (e)=>{ if(e.target=== $("settingsBackdrop")) $("settingsBackdrop").style.display="none"; });
$("jpgq").addEventListener("input", ()=> $("jpgqLabel").textContent = $("jpgq").value);

/* ----------------- State ----------------- */
const A4_W = 2480, A4_H = 3508;

const S = {
  cvReady: false,

  frontBmp: null,
  backBmp: null,

  // points stored in IMAGE coordinates (bmp pixel coords) => zoom/pan safe
  frontPtsImg: [], // array of {x,y} len 0..4
  backPtsImg: [],

  // view transform per canvas
  view: {
    front: {scale: 1, ox: 0, oy: 0},
    back:  {scale: 1, ox: 0, oy: 0}
  },

  // active interactions
  drag: null, // {which, idx} or null
  pointers: new Map(), // pointerId -> {x,y}
  pinch: null, // {which, startDist, startScale, midX, midY}

  // warp canvases (HTMLCanvasElement, iOS safe)
  frontWarp: null,
  backWarp: null,

  xLines: [], yLines: [], cells: []
};

/* ----------------- OpenCV ready (reliable) ----------------- */
window.Module = window.Module || {};
Module.onRuntimeInitialized = () => {
  S.cvReady = true;
  setStatus("bereit. OpenCV.js ist geladen.");
};

/* ----------------- File pickers ----------------- */
$("btnFrontCam").addEventListener("click", ()=> $("frontCam").click());
$("btnFrontPick").addEventListener("click", ()=> $("frontPick").click());
$("btnBackCam").addEventListener("click", ()=> $("backCam").click());
$("btnBackPick").addEventListener("click", ()=> $("backPick").click());

$("frontCam").addEventListener("change", (e)=> loadImageFromInput(e, "front"));
$("frontPick").addEventListener("change", (e)=> loadImageFromInput(e, "front"));
$("backCam").addEventListener("change", (e)=> loadImageFromInput(e, "back"));
$("backPick").addEventListener("change", (e)=> loadImageFromInput(e, "back"));

async function loadImageFromInput(e, which){
  const f = e.target.files?.[0];
  if(!f) return;
  const bmp = await createImageBitmap(f);

  if(which==="front"){
    S.frontBmp = bmp;
    S.frontPtsImg = [];
    resetView("front");
    $("frontState").textContent = "geladen";
    $("frontState").className = "badge ok";
    enableFrontTools(true);
    renderPhoto("front");
    setStatus("Front geladen. Tippe 4 Ecken (TL‚ÜíTR‚ÜíBR‚ÜíBL), dann Entzerren.");
    // enable back pickers
    $("btnBackCam").disabled = false;
    $("btnBackPick").disabled = false;
  } else {
    S.backBmp = bmp;
    S.backPtsImg = [];
    resetView("back");
    $("backState").textContent = "geladen";
    $("backState").className = "badge ok";
    enableBackTools(true);
    renderPhoto("back");
    setStatus("Back geladen. Tippe 4 Ecken, dann Entzerren.");
  }
}

function enableFrontTools(on){
  $("btnFrontManual").disabled = !on;
  $("btnFrontWarp").disabled = true;
  $("btnFrontZoomIn").disabled = !on;
  $("btnFrontZoomOut").disabled = !on;
  $("btnFrontResetView").disabled = !on;
}
function enableBackTools(on){
  $("btnBackManual").disabled = !on;
  $("btnBackWarp").disabled = true;
  $("btnBackZoomIn").disabled = !on;
  $("btnBackZoomOut").disabled = !on;
  $("btnBackResetView").disabled = !on;
}

/* ----------------- View transform + drawing ----------------- */
function resetView(which){
  const v = S.view[which];
  v.scale = 1;
  v.ox = 0;
  v.oy = 0;
}

function renderPhoto(which){
  const canvas = which==="front" ? $("frontCanvas") : $("backCanvas");
  const bmp = which==="front" ? S.frontBmp : S.backBmp;
  if(!bmp) return;

  const ctx = canvas.getContext("2d");
  ctx.setTransform(1,0,0,1,0,0);
  ctx.clearRect(0,0,canvas.width,canvas.height);

  // base "contain" fit
  const baseR = Math.min(canvas.width/bmp.width, canvas.height/bmp.height);
  const baseW = bmp.width*baseR, baseH = bmp.height*baseR;
  const baseX = (canvas.width-baseW)/2, baseY = (canvas.height-baseH)/2;

  // apply user view (pan/zoom around canvas center-ish)
  const v = S.view[which];
  ctx.save();
  ctx.translate(baseX + v.ox, baseY + v.oy);
  ctx.scale(v.scale, v.scale);
  ctx.drawImage(bmp, 0, 0, baseW, baseH);
  ctx.restore();

  // overlay points (convert img->view)
  drawPointsOverlay(which, {baseR, baseX, baseY, baseW, baseH});
}

function imgToView(which, imgPt, fit){
  // image px -> base fit coords -> then view transform
  const v = S.view[which];
  const x0 = fit.baseX + v.ox;
  const y0 = fit.baseY + v.oy;
  const sx = v.scale;
  // first map image->base-fit
  const px = imgPt.x * fit.baseR;
  const py = imgPt.y * fit.baseR;
  // then apply view
  return { x: x0 + px*sx, y: y0 + py*sx };
}

function viewToImg(which, viewPt){
  // inverse mapping from current render
  const canvas = which==="front" ? $("frontCanvas") : $("backCanvas");
  const bmp = which==="front" ? S.frontBmp : S.backBmp;
  if(!bmp) return null;

  const baseR = Math.min(canvas.width/bmp.width, canvas.height/bmp.height);
  const baseW = bmp.width*baseR, baseH = bmp.height*baseR;
  const baseX = (canvas.width-baseW)/2, baseY = (canvas.height-baseH)/2;

  const v = S.view[which];
  const x0 = baseX + v.ox;
  const y0 = baseY + v.oy;

  const sx = v.scale;
  const px = (viewPt.x - x0) / sx;
  const py = (viewPt.y - y0) / sx;

  const ix = px / baseR;
  const iy = py / baseR;

  return { x: clamp(ix, 0, bmp.width-1), y: clamp(iy, 0, bmp.height-1) };
}

function drawPointsOverlay(which, fit){
  const canvas = which==="front" ? $("frontCanvas") : $("backCanvas");
  const ctx = canvas.getContext("2d");
  const pts = which==="front" ? S.frontPtsImg : S.backPtsImg;

  // handles: big + with halo so you feel it under the finger
  const R = 16;
  ctx.save();
  ctx.lineWidth = 4;

  // polygon if 4 points
  if(pts.length===4){
    ctx.strokeStyle = "rgba(0,255,120,.95)";
    ctx.beginPath();
    const p0 = imgToView(which, pts[0], fit);
    ctx.moveTo(p0.x,p0.y);
    for(let i=1;i<4;i++){
      const pi = imgToView(which, pts[i], fit);
      ctx.lineTo(pi.x,pi.y);
    }
    ctx.closePath();
    ctx.stroke();
  }

  for(let i=0;i<pts.length;i++){
    const p = imgToView(which, pts[i], fit);

    // halo
    ctx.fillStyle = "rgba(0,0,0,.35)";
    ctx.beginPath(); ctx.arc(p.x, p.y, R+10, 0, Math.PI*2); ctx.fill();

    // handle
    ctx.fillStyle = "rgba(0,255,120,.95)";
    ctx.beginPath(); ctx.arc(p.x, p.y, R, 0, Math.PI*2); ctx.fill();

    // label
    ctx.fillStyle="#000";
    ctx.font="20px -apple-system";
    ctx.fillText(String(i+1), p.x+R+8, p.y-8);
  }

  // next-step hint
  if(pts.length < 4){
    ctx.fillStyle="rgba(255,255,255,.95)";
    ctx.font="22px -apple-system";
    ctx.fillText(`Tippe Ecke ${pts.length+1}/4`, 16, 34);
  }
  ctx.restore();
}

/* ----------------- Manual mode: tap-to-set + drag + pinch/pan ----------------- */
$("btnFrontManual").addEventListener("click", ()=> startManual("front"));
$("btnBackManual").addEventListener("click", ()=> startManual("back"));

function startManual(which){
  const bmp = which==="front" ? S.frontBmp : S.backBmp;
  if(!bmp) return;
  // clear points => user sets fresh (no pre-rectangle)
  if(which==="front") S.frontPtsImg = [];
  else S.backPtsImg = [];

  // enable warp only after 4 points
  if(which==="front") $("btnFrontWarp").disabled = true;
  else $("btnBackWarp").disabled = true;

  hookCanvasInteractions(which);
  renderPhoto(which);
  setStatus(`${which.toUpperCase()}: Tippe 4 Ecken (TL‚ÜíTR‚ÜíBR‚ÜíBL). Danach ziehen + Entzerren.`);
}

function hookCanvasInteractions(which){
  const canvas = which==="front" ? $("frontCanvas") : $("backCanvas");
  canvas.onpointerdown = (e)=> onPointerDown(which, canvas, e);
  canvas.onpointermove = (e)=> onPointerMove(which, canvas, e);
  canvas.onpointerup   = (e)=> onPointerUp(which, canvas, e);
  canvas.onpointercancel = (e)=> onPointerUp(which, canvas, e);
}

function localPoint(canvas, e){
  const r = canvas.getBoundingClientRect();
  return {
    x:(e.clientX-r.left)*(canvas.width/r.width),
    y:(e.clientY-r.top)*(canvas.height/r.height)
  };
}

function nearestHandle(which, viewPt){
  const canvas = which==="front" ? $("frontCanvas") : $("backCanvas");
  const bmp = which==="front" ? S.frontBmp : S.backBmp;
  const pts = which==="front" ? S.frontPtsImg : S.backPtsImg;
  if(!bmp || pts.length===0) return null;

  // compute fit used in render
  const baseR = Math.min(canvas.width/bmp.width, canvas.height/bmp.height);
  const baseW = bmp.width*baseR, baseH = bmp.height*baseR;
  const baseX = (canvas.width-baseW)/2, baseY = (canvas.height-baseH)/2;
  const fit = {baseR, baseX, baseY, baseW, baseH};

  let best=null;
  for(let i=0;i<pts.length;i++){
    const p = imgToView(which, pts[i], fit);
    const d = Math.hypot(p.x-viewPt.x, p.y-viewPt.y);
    if(best===null || d<best.d) best={i,d};
  }
  if(best && best.d < 55) return best.i; // generous for finger
  return null;
}

function onPointerDown(which, canvas, e){
  canvas.setPointerCapture(e.pointerId);
  const p = localPoint(canvas, e);
  S.pointers.set(e.pointerId, p);

  const pts = which==="front" ? S.frontPtsImg : S.backPtsImg;

  // 2-finger pinch starts when second pointer arrives
  if(S.pointers.size === 2){
    const arr = [...S.pointers.values()];
    const d = Math.hypot(arr[0].x-arr[1].x, arr[0].y-arr[1].y);
    const midX = (arr[0].x+arr[1].x)/2;
    const midY = (arr[0].y+arr[1].y)/2;
    S.pinch = {which, startDist:d, startScale:S.view[which].scale, midX, midY};
    S.drag = null;
    return;
  }

  // if 1 pointer: check handle drag
  const hit = nearestHandle(which, p);
  if(hit !== null){
    S.drag = {which, idx: hit};
    return;
  }

  // otherwise: if points < 4 => set next point on tap
  // (we don't set immediately on down; we set on up if no pan happened)
  S.drag = {which, idx: -1, maybeTap: true, start:p};
}

function onPointerMove(which, canvas, e){
  if(!S.pointers.has(e.pointerId)) return;
  const p = localPoint(canvas, e);
  S.pointers.set(e.pointerId, p);

  // pinch zoom
  if(S.pointers.size === 2 && S.pinch && S.pinch.which===which){
    const arr = [...S.pointers.values()];
    const d = Math.hypot(arr[0].x-arr[1].x, arr[0].y-arr[1].y);
    const ratio = d / (S.pinch.startDist || 1);
    const newScale = clamp(S.pinch.startScale * ratio, 1, 6);

    // keep zoom centered roughly
    S.view[which].scale = newScale;
    renderPhoto(which);
    return;
  }

  // drag point
  if(S.drag && S.drag.which===which && S.drag.idx >= 0){
    const pts = which==="front" ? S.frontPtsImg : S.backPtsImg;
    const imgPt = viewToImg(which, p);
    pts[S.drag.idx] = imgPt;
    renderPhoto(which);
    return;
  }

  // one-finger pan if user moved a bit (and not dragging a handle)
  if(S.drag && S.drag.which===which && S.drag.idx === -1){
    const dx = p.x - S.drag.start.x;
    const dy = p.y - S.drag.start.y;
    if(Math.hypot(dx,dy) > 8){
      S.drag.maybeTap = false; // it's a pan
      S.view[which].ox += dx;
      S.view[which].oy += dy;
      S.drag.start = p;
      renderPhoto(which);
    }
  }
}

function onPointerUp(which, canvas, e){
  const p = localPoint(canvas, e);
  S.pointers.delete(e.pointerId);

  // end pinch when pointers drop
  if(S.pointers.size < 2) S.pinch = null;

  // tap-to-set
  if(S.drag && S.drag.which===which && S.drag.idx === -1 && S.drag.maybeTap){
    const pts = which==="front" ? S.frontPtsImg : S.backPtsImg;
    if(pts.length < 4){
      pts.push(viewToImg(which, p));
      renderPhoto(which);
      if(pts.length === 4){
        if(which==="front") $("btnFrontWarp").disabled = false;
        else $("btnBackWarp").disabled = false;
        setStatus(`${which.toUpperCase()}: 4 Punkte gesetzt. Jetzt Entzerren.`);
      } else {
        setStatus(`${which.toUpperCase()}: Punkt ${pts.length}/4 gesetzt.`);
      }
    }
  }

  S.drag = null;
}

/* zoom buttons */
$("btnFrontZoomIn").addEventListener("click", ()=>{ S.view.front.scale = clamp(S.view.front.scale*1.25, 1, 6); renderPhoto("front"); });
$("btnFrontZoomOut").addEventListener("click", ()=>{ S.view.front.scale = clamp(S.view.front.scale/1.25, 1, 6); renderPhoto("front"); });
$("btnFrontResetView").addEventListener("click", ()=>{ resetView("front"); renderPhoto("front"); });

$("btnBackZoomIn").addEventListener("click", ()=>{ S.view.back.scale = clamp(S.view.back.scale*1.25, 1, 6); renderPhoto("back"); });
$("btnBackZoomOut").addEventListener("click", ()=>{ S.view.back.scale = clamp(S.view.back.scale/1.25, 1, 6); renderPhoto("back"); });
$("btnBackResetView").addEventListener("click", ()=>{ resetView("back"); renderPhoto("back"); });

/* ----------------- Warp (fixed for iPhone) ----------------- */
$("btnFrontWarp").addEventListener("click", ()=> warpA4("front"));
$("btnBackWarp").addEventListener("click", ()=> warpA4("back"));

function bitmapToCanvas(bmp){
  const c = document.createElement("canvas");
  c.width=bmp.width; c.height=bmp.height;
  c.getContext("2d").drawImage(bmp,0,0);
  return c;
}

async function warpA4(which){
  if(!S.cvReady) {
    alert("OpenCV.js l√§dt noch. Bitte 1‚Äì2 Sekunden warten und nochmal.");
    return;
  }

  const bmp = which==="front" ? S.frontBmp : S.backBmp;
  const pts = which==="front" ? S.frontPtsImg : S.backPtsImg;
  if(!bmp || pts.length!==4) {
    alert("Bitte zuerst 4 Ecken tippen (TL‚ÜíTR‚ÜíBR‚ÜíBL).");
    return;
  }

  setStatus(`${which.toUpperCase()}: Entzerren l√§uft‚Ä¶`);

  try{
    const srcCanvas = bitmapToCanvas(bmp);
    const src = cv.imread(srcCanvas);

    const srcTri = cv.matFromArray(4,1,cv.CV_32FC2,[
      pts[0].x, pts[0].y,
      pts[1].x, pts[1].y,
      pts[2].x, pts[2].y,
      pts[3].x, pts[3].y
    ]);
    const dstTri = cv.matFromArray(4,1,cv.CV_32FC2,[
      0,0,
      A4_W,0,
      A4_W,A4_H,
      0,A4_H
    ]);

    const M = cv.getPerspectiveTransform(srcTri, dstTri);
    const dst = new cv.Mat();
    const dsize = new cv.Size(A4_W, A4_H);
    cv.warpPerspective(src, dst, M, dsize, cv.INTER_LINEAR, cv.BORDER_CONSTANT, new cv.Scalar(255,255,255,255));

    // iPhone-safe: imshow into normal canvas
    const outCanvas = which==="front" ? $("frontWarpCanvas") : $("backWarpCanvas");
    cv.imshow(outCanvas, dst);

    // store
    if(which==="front"){
      S.frontWarp = outCanvas;
      $("frontState").textContent = "entzerrt";
      $("frontState").className = "badge ok";
      $("gridState").textContent = "Front ok ‚Üí Grid m√∂glich";
      $("gridState").className = "badge ok";
      enableGridTools(true);
      renderGrid();
      setStatus("Front entzerrt. Jetzt Back entzerren, dann Grid anwenden.");
    }else{
      S.backWarp = outCanvas;
      $("backState").textContent = "entzerrt";
      $("backState").className = "badge ok";
      setStatus("Back entzerrt. Jetzt Grid ‚Üí Preview ‚Üí Export.");
    }

    // cleanup
    src.delete(); dst.delete(); M.delete(); srcTri.delete(); dstTri.delete();

  }catch(err){
    console.error(err);
    alert("Entzerren fehlgeschlagen. Siehe Konsole. (Meist OpenCV nicht geladen oder iOS blockt was)");
    setStatus("Entzerren fehlgeschlagen.");
  }
}

/* ----------------- Grid tools ----------------- */
function enableGridTools(on){
  $("btnGridClear").disabled = !on;
  $("btnGridSave").disabled = !on;
  $("btnGridLoad").disabled = !on;
  $("btnGridApply").disabled = !on;
}

$("btnGridClear").addEventListener("click", ()=>{
  S.xLines=[]; S.yLines=[];
  renderGrid();
  setStatus("Grid reset.");
});

$("btnGridSave").addEventListener("click", ()=>{
  if(!S.frontWarp) return alert("Erst Front entzerren.");
  const data = { version:1,
    x_rel: S.xLines.map(x=>x/A4_W).sort((a,b)=>a-b),
    y_rel: S.yLines.map(y=>y/A4_H).sort((a,b)=>a-b),
  };
  downloadBlob(new Blob([JSON.stringify(data,null,2)],{type:"application/json"}),"grid.json");
});

$("btnGridLoad").addEventListener("click", ()=> $("gridLoad").click());
$("gridLoad").addEventListener("change", async (e)=>{
  const f=e.target.files?.[0]; if(!f) return;
  const j=JSON.parse(await f.text());
  S.xLines=(j.x_rel||[]).map(r=>Math.round(r*A4_W));
  S.yLines=(j.y_rel||[]).map(r=>Math.round(r*A4_H));
  renderGrid();
  setStatus("Grid geladen.");
});

$("btnGridApply").addEventListener("click", ()=>{
  if(!S.frontWarp) return alert("Front fehlt.");
  if(!S.backWarp) return alert("Back ist Pflicht ‚Äì bitte Back entzerren.");
  buildCells();
  $("btnPreview").disabled = (S.cells.length===0);
  $("btnExport").disabled = (S.cells.length===0);
  $("prevState").textContent = S.cells.length ? "bereit" : "wartet";
  $("prevState").className = S.cells.length ? "badge ok" : "badge warn";
  $("expState").textContent = S.cells.length ? "bereit" : "wartet";
  $("expState").className = S.cells.length ? "badge ok" : "badge warn";
  setStatus(`Grid angewandt: ${S.cells.length} Zellen.`);
});

function renderGrid(){
  const c=$("gridCanvas");
  const ctx=c.getContext("2d");
  ctx.setTransform(1,0,0,1,0,0);
  ctx.clearRect(0,0,c.width,c.height);

  if(!S.frontWarp){
    ctx.fillStyle="#222"; ctx.fillRect(0,0,c.width,c.height);
    ctx.fillStyle="#fff"; ctx.font="24px -apple-system";
    ctx.fillText("Erst Front entzerren.", 20, 50);
    return;
  }

  // draw fitted A4 warp
  const rr = Math.min(c.width/A4_W, c.height/A4_H);
  const w=A4_W*rr, h=A4_H*rr;
  const ox=(c.width-w)/2, oy=(c.height-h)/2;
  ctx.drawImage(S.frontWarp, ox, oy, w, h);

  const xs=[0,...S.xLines.sort((a,b)=>a-b),A4_W];
  const ys=[0,...S.yLines.sort((a,b)=>a-b),A4_H];

  ctx.save();
  ctx.lineWidth=2;
  ctx.strokeStyle="rgba(0,120,255,0.9)";
  ctx.fillStyle="rgba(0,120,255,0.9)";
  ctx.font="48px -apple-system";

  for(const xv of xs){
    const X=ox + xv*rr;
    ctx.beginPath(); ctx.moveTo(X,oy); ctx.lineTo(X,oy+h); ctx.stroke();
  }
  for(const yv of ys){
    const Y=oy + yv*rr;
    ctx.beginPath(); ctx.moveTo(ox,Y); ctx.lineTo(ox+w,Y); ctx.stroke();
  }
  let idx=1;
  for(let r=0;r<ys.length-1;r++){
    for(let c2=0;c2<xs.length-1;c2++){
      ctx.fillText(String(idx), ox + xs[c2]*rr + 12, oy + ys[r]*rr + 52);
      idx++;
    }
  }
  ctx.restore();
}

/* tap add line, long-press delete */
let longPressTimer=null;
$("gridCanvas").addEventListener("pointerdown",(e)=>{
  if(!S.frontWarp) return;
  const c=$("gridCanvas");
  c.setPointerCapture(e.pointerId);
  const p = localPoint(c,e);
  longPressTimer=setTimeout(()=>{ deleteNearestGridLine(p.x,p.y); }, 450);
});
$("gridCanvas").addEventListener("pointerup",(e)=>{
  if(!S.frontWarp) return;
  clearTimeout(longPressTimer); longPressTimer=null;
  const c=$("gridCanvas");
  const p = localPoint(c,e);
  addGridLineFromView(p.x,p.y);
});

function viewToA4_grid(x,y){
  const c=$("gridCanvas");
  const rr = Math.min(c.width/A4_W, c.height/A4_H);
  const w=A4_W*rr, h=A4_H*rr;
  const ox=(c.width-w)/2, oy=(c.height-h)/2;
  return { ax:(x-ox)/rr, ay:(y-oy)/rr };
}
function addGridLineFromView(x,y){
  const {ax,ay}=viewToA4_grid(x,y);
  const mode=$("gridMode").value;
  if(mode==="V"){
    S.xLines.push(Math.round(clamp(ax,1,A4_W-1)));
    S.xLines=[...new Set(S.xLines)].sort((a,b)=>a-b);
  }else{
    S.yLines.push(Math.round(clamp(ay,1,A4_H-1)));
    S.yLines=[...new Set(S.yLines)].sort((a,b)=>a-b);
  }
  renderGrid();
}
function deleteNearestGridLine(x,y){
  const {ax,ay}=viewToA4_grid(x,y);
  const thr=12;
  let best=null;
  for(let i=0;i<S.xLines.length;i++){
    const d=Math.abs(S.xLines[i]-ax);
    if(best===null || d<best.d) best={kind:"x",i,d};
  }
  for(let i=0;i<S.yLines.length;i++){
    const d=Math.abs(S.yLines[i]-ay);
    if(best===null || d<best.d) best={kind:"y",i,d};
  }
  if(!best || best.d>thr) return;
  if(best.kind==="x") S.xLines.splice(best.i,1);
  else S.yLines.splice(best.i,1);
  renderGrid();
}

/* ----------------- Cells + Tight + Preview + Export ----------------- */
function buildCells(){
  const pad = parseInt($("gridPad").value||"0",10);
  const xs=[0,...S.xLines,A4_W].sort((a,b)=>a-b);
  const ys=[0,...S.yLines,A4_H].sort((a,b)=>a-b);
  const cells=[];
  for(let r=0;r<ys.length-1;r++){
    for(let c=0;c<xs.length-1;c++){
      let x0=xs[c]+pad, x1=xs[c+1]-pad;
      let y0=ys[r]+pad, y1=ys[r+1]-pad;
      x0=clamp(x0,0,A4_W); x1=clamp(x1,0,A4_W);
      y0=clamp(y0,0,A4_H); y1=clamp(y1,0,A4_H);
      if(x1-x0>5 && y1-y0>5) cells.push({x0,y0,x1,y1});
    }
  }
  S.cells=cells;
}

function cropCanvas(srcCanvas, cell){
  const w=cell.x1-cell.x0, h=cell.y1-cell.y0;
  const c=document.createElement("canvas");
  c.width=w; c.height=h;
  c.getContext("2d").drawImage(srcCanvas, cell.x0,cell.y0,w,h, 0,0,w,h);
  return c;
}

function tightOrFull(cellCanvas){
  if(!$("tight").checked) return cellCanvas;

  const pad = parseInt($("tightPad").value||"0",10);
  const minRatio = parseFloat($("minRatio").value||"0.005");
  const keep = parseFloat($("keep").value||"0.05");

  const w=cellCanvas.width, h=cellCanvas.height;
  const ctx=cellCanvas.getContext("2d",{willReadFrequently:true});
  const img=ctx.getImageData(0,0,w,h);

  let minX=w, minY=h, maxX=0, maxY=0, count=0;
  const thr=245;
  for(let y=0;y<h;y++){
    for(let x=0;x<w;x++){
      const i=(y*w+x)*4;
      const r=img.data[i], g=img.data[i+1], b=img.data[i+2];
      const fg = (r<thr || g<thr || b<thr);
      if(fg){
        count++;
        if(x<minX) minX=x; if(y<minY) minY=y;
        if(x>maxX) maxX=x; if(y>maxY) maxY=y;
      }
    }
  }
  const ratio=count/(w*h);
  if(ratio<minRatio) return cellCanvas;

  minX=clamp(minX-pad,0,w-1); minY=clamp(minY-pad,0,h-1);
  maxX=clamp(maxX+pad,0,w-1); maxY=clamp(maxY+pad,0,h-1);

  const cw=maxX-minX+1, ch=maxY-minY+1;
  if((cw/w)<keep || (ch/h)<keep) return cellCanvas;

  const out=document.createElement("canvas");
  out.width=cw; out.height=ch;
  out.getContext("2d").drawImage(cellCanvas, minX,minY,cw,ch, 0,0,cw,ch);
  return out;
}

function drawFitTo(canvas, src){
  const ctx=canvas.getContext("2d");
  ctx.setTransform(1,0,0,1,0,0);
  ctx.clearRect(0,0,canvas.width,canvas.height);
  const r=Math.min(canvas.width/src.width, canvas.height/src.height);
  const w=src.width*r, h=src.height*r;
  const x=(canvas.width-w)/2, y=(canvas.height-h)/2;
  ctx.drawImage(src,x,y,w,h);
}

$("btnPreview").addEventListener("click", ()=>{
  if(!S.frontWarp || !S.backWarp) return alert("Front & Back m√ºssen entzerrt sein.");
  buildCells();
  if(!S.cells.length) return alert("Grid ergibt keine Zellen.");
  const idx=clamp(parseInt($("idx").value||"1",10), 1, S.cells.length);
  $("idx").value=idx;
  const cell=S.cells[idx-1];

  const f=tightOrFull(cropCanvas(S.frontWarp, cell));
  const b=tightOrFull(cropCanvas(S.backWarp, cell));
  drawFitTo($("knobFront"), f);
  drawFitTo($("knobBack"), b);
  setStatus("Preview aktualisiert.");
});

async function canvasToBlob(c, fmt, q){
  return await new Promise(res=>{
    if(fmt==="png") c.toBlob(res,"image/png");
    else c.toBlob(res,"image/jpeg", q);
  });
}

$("btnExport").addEventListener("click", async ()=>{
  if(!S.frontWarp || !S.backWarp) return alert("Front & Back m√ºssen entzerrt sein.");
  buildCells();
  if(!S.cells.length) return alert("Grid ergibt keine Zellen.");

  const fmt=$("fmt").value;
  const q=parseInt($("jpgq").value,10)/100;
  const doPairs=$("pairs").checked;

  const zip=new JSZip();
  const F=zip.folder("front");
  const B=zip.folder("back");
  const P=doPairs ? zip.folder("pairs") : null;

  setStatus("Export l√§uft‚Ä¶");
  for(let i=0;i<S.cells.length;i++){
    const cell=S.cells[i];

    const f=tightOrFull(cropCanvas(S.frontWarp, cell));
    const b=tightOrFull(cropCanvas(S.backWarp, cell));

    F.file(`front_${String(i+1).padStart(3,"0")}.${fmt}`, await canvasToBlob(f, fmt, q));
    B.file(`back_${String(i+1).padStart(3,"0")}.${fmt}`,  await canvasToBlob(b, fmt, q));

    if(doPairs){
      const pair=document.createElement("canvas");
      pair.width=f.width+b.width; pair.height=Math.max(f.height,b.height);
      const pctx=pair.getContext("2d");
      pctx.fillStyle="#fff"; pctx.fillRect(0,0,pair.width,pair.height);
      pctx.drawImage(f,0,0);
      pctx.drawImage(b,f.width,0);
      P.file(`pair_${String(i+1).padStart(3,"0")}.jpg`, await canvasToBlob(pair,"jpg",q));
    }
    if((i+1)%5===0) setStatus(`Export‚Ä¶ ${i+1}/${S.cells.length}`);
  }

  downloadBlob(await zip.generateAsync({type:"blob"}), "buttongridtool_export.zip");
  setStatus("Fertig. ZIP geladen.");
});
</script>
</body>
</html>
