<!doctype html>
<html lang="de">
<head>
  <link rel="apple-touch-icon" href="icon-180.png">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="default">
  <meta name="apple-mobile-web-app-title" content="ButtonGridTool">
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>ButtonGridTool-Wizard</title>
  <style>
    :root { --pad: 12px; --gap: 10px; --b:#2b6cff; }
    * { box-sizing: border-box; }
    html, body { width:100%; max-width:100%; overflow-x:hidden; }
    body { font-family:-apple-system,system-ui,Segoe UI,Roboto,Arial; margin:0; background:#f5f6f8; padding-top:72px; }

    header {
      background:#fff; border-bottom:1px solid #ddd; padding:10px 12px;
      position:fixed; top:0; left:0; right:0; z-index:50;
      display:flex; align-items:center; justify-content:space-between; gap:10px;
      max-width:100%;
    }
    header h1 { font-size:16px; margin:0; }
    .hdrBtns{ display:flex; gap:10px; align-items:center; flex-wrap:wrap; }

    button, select, input[type="number"], input[type="range"] {
      font-size:16px; padding:10px 12px; border-radius:10px; border:1px solid #bbb; background:#fff;
      max-width:100%;
    }
    button.primary{ background:var(--b); color:#fff; border-color:var(--b); }
    button.danger{ background:#ff3b30; color:#fff; border-color:#ff3b30; }
    button:disabled{ opacity:.5; }
    a { text-decoration:none; }

    main{ padding:var(--pad); padding-top:calc(var(--pad) + 64px); max-width:980px; margin:0 auto; width:100%; }
    .card{ background:#fff; border:1px solid #ddd; border-radius:10px; padding:12px; margin:10px 0; max-width:100%; }
    .row{ display:flex; flex-wrap:wrap; gap:var(--gap); align-items:center; max-width:100%; }
    .pill{ display:inline-flex; gap:8px; align-items:center; padding:8px 10px; border:1px solid #ddd; border-radius:999px; max-width:100%; }
    canvas{ width:100%; height:auto; border:1px solid #ddd; border-radius:10px; background:#000; touch-action:none; max-width:100%; }
    .small{ color:#666; font-size:13px; line-height:1.35; }
    .split{ display:grid; grid-template-columns:1fr 1fr; gap:10px; }
    @media (max-width:720px){ .split{ grid-template-columns:1fr; } }
    .stepTitle{ font-weight:700; margin:0 0 8px 0; display:flex; align-items:center; justify-content:space-between; gap:10px; flex-wrap:wrap;}
    .badge{ font-size:12px; padding:4px 8px; border-radius:999px; border:1px solid #ddd; color:#333; background:#fafafa; }
    .ok{ border-color:#7bd88f; background:#eaffef; }
    .warn{ border-color:#ffd37b; background:#fff5e6; }
    .muted{ color:#777; font-size:13px; }
    .toolbtn{ padding:10px 12px; }
    .hr{ height:1px; background:#eee; margin:10px 0; }

    /* modal */
    .modalBackdrop{
      position:fixed; inset:0; background:rgba(0,0,0,.35);
      display:none; align-items:flex-end; justify-content:center; z-index:999;
      padding:12px;
    }
    .modal{
      width:min(980px, 100%); background:#fff; border-radius:16px; border:1px solid #ddd;
      padding:12px; max-height:82vh; overflow:auto;
    }
    .modalHeader{ display:flex; align-items:center; justify-content:space-between; gap:10px; flex-wrap:wrap; }
    .modalHeader h2{ margin:0; font-size:16px; }
    .mono{ font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; }

    .copyRow{
      display:flex;
      gap:10px;
      align-items:center;
      flex-wrap:wrap;
      max-width:100%;
      width:100%;
    }
    /* iOS / Flex overflow fix */
    .payCard, .pill, .row, .modal { min-width: 0; }

    .copyBox{
      flex:1;
      min-width:0;
      width:100%;
      padding:10px 12px;
      border:1px solid #ddd;
      border-radius:12px;
      background:#fafafa;
      overflow-wrap:anywhere;
      word-break:break-word;
    }

    .ctaGrid{ display:grid; grid-template-columns:1fr 1fr; gap:10px; }
    @media (max-width:720px){ .ctaGrid{ grid-template-columns:1fr; } }

    .payCard{
      border:1px solid #ddd; border-radius:14px; padding:12px; background:#fff;
      display:flex; flex-direction:column; gap:10px;
    }
    .payBtnBig{
      display:flex; align-items:center; justify-content:center;
      border:1px solid #ddd; border-radius:14px; padding:12px; background:#fafafa;
      min-height:64px;
    }
    .payBtnBig:active{ transform: scale(.99); }
    .paypalImg{
      width:160px; max-width:80%; height:auto; display:block;
    }

    .qrImg{
      width:220px; height:220px;
      background:#fff; border-radius:12px; border:1px solid #ddd;
      display:block;
    }
  </style>
</head>
<body>
<header>
  <h1>ButtonGridTool-Wizard</h1>
  <div class="hdrBtns">
    <button id="btnHelp" title="Hilfe">?</button>
    <button id="btnDonate" title="Spenden">‚òïÔ∏è</button>
    <button id="btnGear" title="Einstellungen">‚öôÔ∏è</button>
  </div>
</header>

<main>
  <!-- STEP 1 FRONT -->
  <div class="card">
    <div class="stepTitle">
      <span>Step 1 ‚Äì Front</span>
      <span id="frontState" class="badge warn">nicht geladen</span>
    </div>

    <input id="frontCam" type="file" accept="image/*" capture="environment" hidden />
    <input id="frontPick" type="file" accept="image/*" hidden />

    <div class="row">
      <button id="btnFrontCam" class="primary">üì∑ Foto machen</button>
      <button id="btnFrontPick">üìÅ Datei benutzen</button>

      <span class="pill"><b>Format</b>
        <select id="warpFormat">
          <option value="A4_L">A4 quer</option>
          <option value="A4_P" selected>A4 hoch</option>
          <option value="A5_L">A5 quer</option>
          <option value="A5_P">A5 hoch</option>
        </select>
      </span>

      <button id="btnFrontManual" disabled>Manuell 4 Ecken</button>
      <button id="btnFrontWarp" class="primary" disabled>Entzerren (A4 hoch)</button>
      <button id="btnFrontSkipWarp" disabled>Ohne Entzerren weiter</button>

      <button id="btnFrontResetView" class="toolbtn" disabled>Reset View</button>
    </div>

    <canvas id="frontCanvas" width="1200" height="900"></canvas>

    <p class="small">
      <b>Ecken setzen:</b> Tippe 4√ó die <b>Papier-Ecken</b>: <b>TL ‚Üí TR ‚Üí BR ‚Üí BL</b>. Danach Punkte ziehen. <br>
      <b>Zoom/Pan:</b> Pinch-Zoom + ziehen. Punkte bleiben stabil. Dann <b>Entzerren</b> (oder <b>Ohne Entzerren</b>).
    </p>
  </div>

  <!-- STEP 2 BACK -->
  <div class="card">
    <div class="stepTitle">
      <span>Step 2 ‚Äì Back</span>
      <span id="backState" class="badge warn">wartet</span>
    </div>

    <input id="backCam" type="file" accept="image/*" capture="environment" hidden />
    <input id="backPick" type="file" accept="image/*" hidden />

    <div class="row">
      <button id="btnBackCam" class="primary" disabled>üì∑ Foto machen</button>
      <button id="btnBackPick" disabled>üìÅ Datei benutzen</button>

      <button id="btnBackManual" disabled>Manuell 4 Ecken</button>
      <button id="btnBackWarp" class="primary" disabled>Entzerren</button>
      <button id="btnBackSkipWarp" disabled>Ohne Entzerren weiter</button>

      <button id="btnBackResetView" class="toolbtn" disabled>Reset View</button>
    </div>

    <canvas id="backCanvas" width="1200" height="900"></canvas>
    <p class="small muted">
      Tipp: Wenn du ohne Entzerren arbeitest, mach Front/Back m√∂glichst gleich: gleiche Entfernung, gleicher Winkel.
    </p>
  </div>

  <!-- STEP 3 GRID -->
  <div class="card">
    <div class="stepTitle">
      <span>Step 3 ‚Äì Grid</span>
      <span id="gridState" class="badge warn">wartet auf Front</span>
    </div>

    <div class="row">
      <span class="pill"><b>Ansicht</b>
        <select id="gridWhich">
          <option value="front" selected>Front</option>
          <option value="back">Back</option>
        </select>
      </span>

      <span class="pill"><b>Mode</b>
        <select id="gridMode">
          <option value="V" selected>Vertikal</option>
          <option value="H">Horizontal</option>
        </select>
      </span>

      <button id="btnUndo" disabled>‚Ü©Ô∏é Schritt zur√ºck</button>
      <button id="btnGridResetView" class="toolbtn" disabled>Reset View</button>

      <button id="btnGridClear" class="danger" disabled>Alles l√∂schen</button>
      <button id="btnGridSave" disabled>Save</button>
      <input id="gridLoad" type="file" accept="application/json" hidden />
      <button id="btnGridLoad" disabled>Load</button>

      <button id="btnGridApply" class="primary" disabled>Grid anwenden</button>
    </div>

    <canvas id="gridCanvas" width="1200" height="900"></canvas>

    <p class="small">
      <b>Linien:</b> Tap = Linie setzen ¬∑ <b>Pinch/Drag = Zoom/Pan</b> (setzt keine Linien) <br>
      <b>Zellen:</b> <b>Doppeltipp</b> auf eine Zelle = aus/ein (aus = rot, wird nicht exportiert) <br>
      <b>Back check:</b> Umschalten auf <b>Back</b> und schauen, ob was abgeschnitten w√§re.
    </p>
  </div>

  <!-- STEP 4 PREVIEW -->
  <div class="card">
    <div class="stepTitle">
      <span>Step 4 ‚Äì Preview</span>
      <span id="prevState" class="badge warn">wartet</span>
    </div>

    <div class="row">
      <span class="pill"><b>Knopf #</b>
        <input id="idx" type="number" value="1" min="1" step="1" style="width:90px;">
      </span>
      <button id="btnPreview" class="primary" disabled>Preview</button>

      <span class="pill"><b>Pairs</b>
        <input id="pairs" type="checkbox" checked />
      </span>
    </div>

    <div class="split">
      <div>
        <p class="small"><b>Front</b></p>
        <canvas id="knobFront" width="900" height="450"></canvas>
      </div>
      <div>
        <p class="small"><b>Back</b></p>
        <canvas id="knobBack" width="900" height="450"></canvas>
      </div>
    </div>

    <div style="margin-top:10px;">
      <p class="small" id="pairLabel"><b>Pair</b> (Front+Back)</p>
      <canvas id="knobPair" width="1200" height="450"></canvas>
    </div>
  </div>

  <!-- STEP 5 EXPORT -->
  <div class="card">
    <div class="stepTitle">
      <span>Step 5 ‚Äì Export</span>
      <span id="expState" class="badge warn">wartet</span>
    </div>
    <div class="row">
      <button id="btnExport" class="primary" disabled>ZIP Export</button>
    </div>
    <p id="status" class="small">Status: OpenCV.js l√§dt‚Ä¶</p>
  </div>
</main>

<!-- SETTINGS MODAL -->
<div id="settingsBackdrop" class="modalBackdrop" style="display:none;">
  <div class="modal">

    <div class="modalHeader">
      <h2>‚öôÔ∏è Einstellungen</h2>
      <button id="btnSettingsClose">Schlie√üen</button>
    </div>

    <p class="muted">Ausgabe ¬∑ Zellzuschnitt ¬∑ Objekterkennung ¬∑ Stabilit√§t</p>
    <div class="hr"></div>

    <div class="row">
      <button id="btnSettingsSave">‚öôÔ∏è Einstellungen speichern</button>
      <input id="settingsLoad" type="file" accept="application/json" hidden />
      <button id="btnSettingsLoad">‚öôÔ∏è Einstellungen laden</button>
    </div>

    <div class="hr"></div>

    <!-- AUSGABE -->
    <p class="small"><b>Ausgabeformat</b></p>
    <div class="row">
      <span class="pill">
        <b>Dateiformat</b>
        <select id="fmt">
          <option value="jpg" selected>JPG (kleiner)</option>
          <option value="png">PNG (verlustfrei)</option>
        </select>
      </span>

      <span class="pill">
        <b>JPG-Qualit√§t</b>
        <input id="jpgq" type="range" min="50" max="100" value="92">
        <span id="jpgqLabel">92</span>
      </span>
    </div>

    <div class="hr"></div>

    <!-- ZELLZUSCHNITT -->
    <p class="small"><b>Zell-Zuschnitt (vor Objekterkennung)</b></p>
    <div class="row">
      <span class="pill">
        <b>Rand innerhalb jeder Zelle (Pixel)</b>
        <input id="gridPad" type="number" value="15" min="0" max="300" step="1" style="width:90px;">
      </span>
    </div>

    <div class="hr"></div>

    <!-- OBJEKT -->
    <p class="small"><b>Objekt automatisch zuschneiden</b></p>
    <div class="row">
      <span class="pill">
        <b>Automatisch zuschneiden</b>
        <input id="tight" type="checkbox" checked>
      </span>

      <span class="pill">
        <b>Sicherheitsrand um Objekt (Pixel)</b>
        <input id="tightPad" type="number" value="12" min="0" max="200" step="1" style="width:90px;">
      </span>

      <span class="pill">
        <b>Min. Objektanteil (Notfall)</b>
        <input id="minRatio" type="number" value="0.005" min="0.0001" max="0.5" step="0.0005" style="width:110px;">
      </span>

      <span class="pill">
        <b>Min. Crop-Gr√∂√üe (Notfall)</b>
        <input id="keep" type="number" value="0.05" min="0.01" max="0.9" step="0.01" style="width:110px;">
      </span>

      <span class="pill">
        <b>Debug-Overlay anzeigen</b>
        <input id="debugOverlay" type="checkbox">
      </span>
    </div>

    <div class="hr"></div>

    <!-- STABILIT√ÑT -->
    <p class="small"><b>Stabilit√§t der Erkennung</b></p>
    <div class="row">
      <span class="pill">
        <b>Kante muss mehrmals passen</b>
        <input id="edgeRun" type="number" value="2" min="1" max="8" step="1" style="width:90px;">
      </span>

      <span class="pill">
        <b>Startabstand vom Zellrand (Pixel)</b>
        <input id="edgeOff" type="number" value="6" min="0" max="80" step="1" style="width:90px;">
      </span>
    </div>

    <div class="hr"></div>

    <!-- FRONT -->
    <p class="small"><b>Vorderseite ‚Äì Objektrand erkennen</b></p>
    <div class="row">
      <span class="pill"><b>Oben ‚Äì Empfindlichkeit</b><input id="fThrT" type="number" value="35" min="1" max="255" style="width:90px;"></span>
      <span class="pill"><b>Oben ‚Äì Mindestanteil</b><input id="fFillT" type="number" value="0.02" step="0.005" style="width:110px;"></span>

      <span class="pill"><b>Rechts ‚Äì Empfindlichkeit</b><input id="fThrR" type="number" value="35" min="1" max="255" style="width:90px;"></span>
      <span class="pill"><b>Rechts ‚Äì Mindestanteil</b><input id="fFillR" type="number" value="0.02" step="0.005" style="width:110px;"></span>

      <span class="pill"><b>Unten ‚Äì Empfindlichkeit</b><input id="fThrB" type="number" value="35" min="1" max="255" style="width:90px;"></span>
      <span class="pill"><b>Unten ‚Äì Mindestanteil</b><input id="fFillB" type="number" value="0.02" step="0.005" style="width:110px;"></span>

      <span class="pill"><b>Links ‚Äì Empfindlichkeit</b><input id="fThrL" type="number" value="35" min="1" max="255" style="width:90px;"></span>
      <span class="pill"><b>Links ‚Äì Mindestanteil</b><input id="fFillL" type="number" value="0.02" step="0.005" style="width:110px;"></span>
    </div>

    <div class="hr"></div>

    <!-- BACK -->
    <p class="small"><b>R√ºckseite ‚Äì Objektrand erkennen (Schatten!)</b></p>
    <div class="row">
      <span class="pill"><b>Oben ‚Äì Empfindlichkeit</b><input id="bThrT" type="number" value="28" min="1" max="255" style="width:90px;"></span>
      <span class="pill"><b>Oben ‚Äì Mindestanteil</b><input id="bFillT" type="number" value="0.015" step="0.005" style="width:110px;"></span>

      <span class="pill"><b>Rechts ‚Äì Empfindlichkeit</b><input id="bThrR" type="number" value="28" min="1" max="255" style="width:90px;"></span>
      <span class="pill"><b>Rechts ‚Äì Mindestanteil</b><input id="bFillR" type="number" value="0.015" step="0.005" style="width:110px;"></span>

      <span class="pill"><b>Unten ‚Äì Empfindlichkeit</b><input id="bThrB" type="number" value="22" min="1" max="255" style="width:90px;"></span>
      <span class="pill"><b>Unten ‚Äì Mindestanteil</b><input id="bFillB" type="number" value="0.012" step="0.005" style="width:110px;"></span>

      <span class="pill"><b>Links ‚Äì Empfindlichkeit</b><input id="bThrL" type="number" value="28" min="1" max="255" style="width:90px;"></span>
      <span class="pill"><b>Links ‚Äì Mindestanteil</b><input id="bFillL" type="number" value="0.015" step="0.005" style="width:110px;"></span>
    </div>

    <div class="hr"></div>

    <p class="small">
      <b>Legende:</b><br>
      <b>Rand innerhalb jeder Zelle:</b> entfernt Gridlinien & Randartefakte.<br>
      <b>Automatisch zuschneiden:</b> erkennt das Objekt und entfernt Hintergrund.<br>
      <b>Sicherheitsrand:</b> zus√§tzlicher Abstand um das Objekt.<br>
      <b>Empfindlichkeit:</b> n√∂tiger Kontrast zwischen Objekt & Papier (h√∂her = vorsichtiger).<br>
      <b>Mindestanteil:</b> wie viel Objekt in einer Zeile/Spalte sein muss, damit dort ein Rand erkannt wird.<br>
      <b>Kante muss mehrmals passen:</b> sch√ºtzt vor Staub & Rauschen.<br>
      <b>Startabstand:</b> verhindert Fehldetektion direkt am Zellrand.<br>
      <b>Debug-Overlay:</b> gr√ºn = erkannte Objektkante, rot = finaler Zuschnitt.
    </p>

  </div>
</div>
<!-- /SETTINGS MODAL (WICHTIG: hier waren bei dir die Schlie√ü-Tags kaputt!) -->

<!-- HELP MODAL -->
<div id="helpBackdrop" class="modalBackdrop">
  <div class="modal">
    <div class="modalHeader">
      <h2>‚ùì Hilfe</h2>
      <button id="btnHelpClose">Schlie√üen</button>
    </div>

    <div class="hr"></div>

    <p class="small">
      <b>Wof√ºr ist das Tool?</b><br>
      F√ºr Fund-Dokumentation (z.B. Kn√∂pfe): Du legst viele Objekte in ein Raster auf ein Blatt,
      machst ein Foto von <b>Front</b> und <b>Back</b>, definierst einmal ein <b>Grid</b>,
      und bekommst am Ende <b>jede Zelle als eigene Datei</b> (Front/Back und optional Pair).
    </p>

    <p class="small">
      <b>Was kann es?</b><br>
      ‚Ä¢ Manuell 4 Ecken setzen und auf A4/A5 (hoch/quer) perspektivisch entzerren (OpenCV).<br>
      ‚Ä¢ Oder ohne Entzerren weiterarbeiten (wenn Foto sauber/gleichm√§√üig ist).<br>
      ‚Ä¢ Grid-Linien setzen, Zellen per Doppeltipp deaktivieren (rot).<br>
      ‚Ä¢ Vorschau f√ºr Front/Back/Pair, dann Export als ZIP.
    </p>

    <div class="hr"></div>

    <p class="small">
      <b>So nutzt du es korrekt (Kurz-Anleitung)</b><br>
      1) Step 1: Front laden ‚Üí <b>Papierformat w√§hlen</b> (A4/A5, Hoch/Quer) ‚Üí ‚ÄúManuell 4 Ecken‚Äù ‚Üí <b>gemeint sind die 4 Papier-Ecken</b> ‚Üí TL‚ÜíTR‚ÜíBR‚ÜíBL tippen ‚Üí Punkte feinziehen ‚Üí ‚ÄúEntzerren‚Äù (oder ‚ÄúOhne Entzerren‚Äù).<br>
      2) Step 2: Back genauso (wichtig: damit du im Pair siehst, ob was abgeschnitten ist).<br>
      3) Step 3: Grid setzen (Tap = Linie). Pinch/Drag = Zoom/Pan. Ansicht auf Back umschalten zum Check.<br>
      4) Step 4: Preview: Knopf # w√§hlen, Front/Back/Pair pr√ºfen.<br>
      5) Step 5: ZIP Export.
    </p>
    <div class="hr"></div>
    <p class="small muted">
      ¬© 2025 Roland Konrad ¬∑ Lizenz: siehe LICENSE.txt (Non-Commercial)
    </p>
  </div>
</div>

<!-- DONATE MODAL -->
<div id="donateBackdrop" class="modalBackdrop">
  <div class="modal">
    <div class="modalHeader">
      <h2>‚òïÔ∏è Spenden</h2>
      <button id="btnDonateClose">Schlie√üen</button>
    </div>

    <p class="small">
      Wenn dir das Tool Zeit (oder Nerven) spart und du mich unterst√ºtzen willst:
      <b>PayPal</b> oder <b>Bitcoin</b> ‚Äì super einfach. ‚ù§Ô∏è
    </p>

    <div class="ctaGrid">

      <!-- PayPal -->
      <div class="payCard">
        <div class="muted"><b>PayPal</b></div>

        <a class="payBtnBig" href="https://paypal.me/rophko" target="_blank" rel="noopener">
          <img class="paypalImg" alt="PayPal" src="data:image/svg+xml;utf8,
            <svg xmlns='http://www.w3.org/2000/svg' width='420' height='140' viewBox='0 0 420 140'>
              <rect width='420' height='140' rx='24' fill='%23f5f7ff'/>
              <text x='50%25' y='55%25' text-anchor='middle' font-family='Arial' font-size='44' fill='%23003087'>PayPal</text>
              <text x='50%25' y='80%25' text-anchor='middle' font-family='Arial' font-size='20' fill='%23003087'>Jetzt spenden</text>
            </svg>"/>
        </a>

        <div class="small muted">Tippen ‚Üí PayPal √∂ffnet direkt.</div>

        <div class="row" style="margin-top:6px;">
          <button id="btnPaypalQR" type="button">QR anzeigen</button>
        </div>

        <div id="paypalQrWrap" style="display:none; margin-top:8px;">
          <img id="paypalQrImg" class="qrImg" alt="PayPal QR" />
          <div class="small muted" style="margin-top:6px;">Scan ‚Üí PayPal-Link √∂ffnet.</div>
          <div id="paypalQrHint" class="small muted" style="margin-top:6px;"></div>
        </div>
      </div>

      <!-- BTC -->
      <div class="payCard">
        <div class="muted"><b>Bitcoin (BTC)</b></div>

        <div class="copyRow">
          <div class="copyBox mono" id="btcText">bc1qwr08y9ngmvplpr8tuk4w34rl4pkryur8u4cf5f</div>
          <button id="btnCopyBTC">Kopieren</button>
          <a href="bitcoin:bc1qwr08y9ngmvplpr8tuk4w34rl4pkryur8u4cf5f"
             class="primary"
             style="display:inline-flex; align-items:center; justify-content:center; border-radius:10px; padding:10px 12px; border:1px solid var(--b);">
            Jetzt zahlen
          </a>
        </div>

        <div class="row" style="margin-top:6px;">
          <button id="btnBtcQR" type="button">QR anzeigen</button>
        </div>

        <div id="btcQrWrap" style="display:none; margin-top:8px;">
          <img id="btcQrImg" class="qrImg" alt="BTC QR" />
          <div class="small muted" style="margin-top:6px;">Scan ‚Üí Wallet sollte Adresse √ºbernehmen.</div>
          <div id="btcQrHint" class="small muted" style="margin-top:6px;"></div>
        </div>

        <div class="small muted">‚ÄúJetzt zahlen‚Äù klappt in vielen Wallets direkt (sonst kopieren).</div>
      </div>
    </div>

    <div class="hr"></div>

    <p class="small">
      <b>Ohne Kohle auch mega:</b> Wenn du mir eine Freude machen willst ‚Äì abonnier meinen YouTube-Kanal! üôÇ
    </p>
    <a href="https://youtube.com/@rolandkonrad?si=4elPMGYTYBaymTmf&sub_confirmation=1"
       target="_blank" rel="noopener"
       class="primary"
       style="display:inline-flex; align-items:center; justify-content:center; border-radius:12px; padding:12px 14px; border:1px solid var(--b);">
      Klar, ich abonnier direkt!
    </a>
    <div class="hr"></div>

    <p class="small muted" style="text-align:center; margin:10px 0 0;">
      ¬© 2025 Roland Konrad ¬∑ Non-Commercial ¬∑ siehe LICENSE.txt
    </p>
  </div>
</div>

<!-- hidden warp canvases -->
<canvas id="frontWarpCanvas" width="2480" height="3508" hidden></canvas>
<canvas id="backWarpCanvas" width="2480" height="3508" hidden></canvas>

<!-- libs -->
<script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
<script>
  // MUST exist before opencv.js loads
  window.__cvReady = false;

  window.Module = window.Module || {};
  const _prevCvInit = window.Module.onRuntimeInitialized;

  window.Module.onRuntimeInitialized = () => {
    // chain anything that may already exist
    try { _prevCvInit && _prevCvInit(); } catch (e) { console.warn(e); }

    window.__cvReady = true;

    // update UI if available
    const st = document.getElementById("status");
    if (st) st.textContent = "Status: bereit.";

    // update app state if it exists already
    if (window.S) window.S.cvReady = true;

    console.log("OpenCV.js ready");
  };
</script>

<script id="opencvjs" defer src="https://docs.opencv.org/4.x/opencv.js"></script>

<script>
  // robust error handling
  (function(){
    const s = document.getElementById("opencvjs");
    if(!s) return;

    s.addEventListener("error", () => {
      alert("OpenCV.js konnte nicht geladen werden (Netz/Blocker/CSP).");
      console.error("OpenCV.js failed:", s.src);
      const st = document.getElementById("status");
      if (st) st.textContent = "Status: OpenCV.js konnte nicht geladen werden.";
    });

    setTimeout(() => {
      if(!window.__cvReady){
        console.warn("OpenCV.js still not ready after 10s");
      }
    }, 10000);
  })();
</script>


<script type="module">
  import { isHeic, heicTo } from "https://esm.sh/heic-to@1.3.0";
  window.__heicTo = { isHeic, heicTo };
</script>
<script src="https://cdn.jsdelivr.net/npm/heic2any@0.0.4/dist/heic2any.min.js"></script>

<script>
/* ---- Identity / License Marker ---- */
const APP_NAME = "ButtonGridTool-Wizard";
const APP_AUTHOR = "Roland Konrad";
const APP_YEAR = "2025";
const APP_LICENSE_HINT = "Non-commercial use only ‚Äì see LICENSE.txt";

console.log(
  `%c${APP_NAME} ¬© ${APP_YEAR} ${APP_AUTHOR}\n%c${APP_LICENSE_HINT}`,
  "font-weight:bold; color:#2b6cff;",
  "color:#666;"
);

/* ----------------- Utils ----------------- */
const $ = (id)=>document.getElementById(id);
const statusEl = $("status");
function setStatus(s){ statusEl.textContent = "Status: " + s; }
function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
function clampScale(s){ return clamp(s, 1, 6); }
function pad3(n){ return String(n).padStart(3,"0"); }

function downloadBlob(blob, filename){
  const a=document.createElement("a");
  a.href=URL.createObjectURL(blob);
  a.download=filename;
  document.body.appendChild(a);
  a.click();
  a.remove();
  setTimeout(()=>URL.revokeObjectURL(a.href), 1000);
}

async function copyText(t){
  try{
    await navigator.clipboard.writeText(t);
    setStatus("Kopiert.");
  }catch{
    const ta=document.createElement("textarea");
    ta.value=t; document.body.appendChild(ta);
    ta.select(); document.execCommand("copy");
    ta.remove();
    setStatus("Kopiert (fallback).");
  }
}

function localPoint(canvas, e){
  const r=canvas.getBoundingClientRect();
  return {
    x:(e.clientX-r.left)*(canvas.width/r.width),
    y:(e.clientY-r.top)*(canvas.height/r.height)
  };
}

/* ----------------- Modals ----------------- */
function openModal(backdropId){
  const el = $(backdropId);
  if(el) el.style.display = "flex";
}
function closeModal(backdropId){
  const el = $(backdropId);
  if(el) el.style.display = "none";
}

document.addEventListener("DOMContentLoaded", ()=>{
  $("btnGear")?.addEventListener("click", ()=> openModal("settingsBackdrop"));
  $("btnSettingsClose")?.addEventListener("click", ()=> closeModal("settingsBackdrop"));
  $("settingsBackdrop")?.addEventListener("click", (e)=>{ if(e.target === $("settingsBackdrop")) closeModal("settingsBackdrop"); });

  $("btnDonate")?.addEventListener("click", ()=> openModal("donateBackdrop"));
  $("btnDonateClose")?.addEventListener("click", ()=> closeModal("donateBackdrop"));
  $("donateBackdrop")?.addEventListener("click", (e)=>{ if(e.target === $("donateBackdrop")) closeModal("donateBackdrop"); });

  $("btnHelp")?.addEventListener("click", ()=> openModal("helpBackdrop"));
  $("btnHelpClose")?.addEventListener("click", ()=> closeModal("helpBackdrop"));
  $("helpBackdrop")?.addEventListener("click", (e)=>{ if(e.target === $("helpBackdrop")) closeModal("helpBackdrop"); });
});

function toggleWrap(id){
  const el = $(id);
  el.style.display = (el.style.display==="none" || !el.style.display) ? "block" : "none";
}

/* ----------------- QR ----------------- */
const PAYPAL_URL = "https://paypal.me/rophko";
const BTC_ADDR   = "bc1qwr08y9ngmvplpr8tuk4w34rl4pkryur8u4cf5f";
const BTC_URI    = `bitcoin:${BTC_ADDR}`;

function qrImgUrl(text){
  const data = encodeURIComponent(text);
  return `https://api.qrserver.com/v1/create-qr-code/?size=220x220&margin=2&data=${data}`;
}
function setQrImage(imgEl, hintEl, text){
  imgEl.src = qrImgUrl(text);
  hintEl.textContent = "Wenn QR leer bleibt: Internet/Content-Blocker pr√ºfen. Link/Copy geht immer.";
}

$("btnPaypalQR").addEventListener("click", ()=>{
  toggleWrap("paypalQrWrap");
  if($("paypalQrWrap").style.display==="block"){
    setQrImage($("paypalQrImg"), $("paypalQrHint"), PAYPAL_URL);
  }
});
$("btnBtcQR").addEventListener("click", ()=>{
  toggleWrap("btcQrWrap");
  if($("btcQrWrap").style.display==="block"){
    setQrImage($("btcQrImg"), $("btcQrHint"), BTC_URI);
  }
});
$("btnCopyBTC").addEventListener("click", ()=> copyText($("btcText").textContent.trim()));

/* Settings */
$("jpgq").addEventListener("input", ()=> $("jpgqLabel").textContent = $("jpgq").value);
$("jpgqLabel").textContent = $("jpgq").value;

/* robust iOS image load */
async function loadImageFileToCanvas(file){
  const name = (file?.name || "").toLowerCase();
  const type = (file?.type || "").toLowerCase();
  const looksHeic = name.endsWith(".heic") || name.endsWith(".heif") || type.includes("heic") || type.includes("heif");

  let blob = file;

  if(looksHeic){
    try{
      if(window.__heicTo?.isHeic && window.__heicTo?.heicTo){
        const ok = await window.__heicTo.isHeic(file);
        if(ok){
          const out = await window.__heicTo.heicTo({ blob:file, type:"image/jpeg", quality:0.92 });
          blob = out;
        }
      }
    }catch(err){
      console.warn("HEIC->JPG (heic-to) failed, trying heic2any fallback", err);
    }

    if(blob === file){
      try{
        if(typeof window.heic2any === "function"){
          let out = await window.heic2any({ blob:file, toType:"image/jpeg", quality:0.92 });
          if(Array.isArray(out)) out = out[0];
          if(out instanceof Blob) blob = out;
        }
      }catch(err){
        console.warn("HEIC->JPG (heic2any) failed", err);
      }
    }

    if(blob === file){
      try{
        if(window.__heicTo?.heicTo){
          const out = await window.__heicTo.heicTo({ blob:file, type:"image/png" });
          blob = out;
        }
      }catch(err){
        console.error("HEIC->PNG failed", err);
      }
    }

    if(blob === file){
      throw new Error("Konnte diese HEIC/HEIF-Datei nicht decodieren.");
    }
  }

  const url = URL.createObjectURL(blob);
  try{
    const img = new Image();
    img.decoding = "async";
    img.src = url;
    await img.decode();
    const c = document.createElement("canvas");
    c.width = img.naturalWidth;
    c.height = img.naturalHeight;
    c.getContext("2d").drawImage(img, 0, 0);
    return c;
  } finally {
    URL.revokeObjectURL(url);
  }
}

/* ----------------- State ----------------- */
const PAPER = {
  A4_P:{ key:"A4_P", label:"A4 hoch", w:2480, h:3508 },
  A4_L:{ key:"A4_L", label:"A4 quer", w:3508, h:2480 },
  A5_P:{ key:"A5_P", label:"A5 hoch", w:1748, h:2480 },
  A5_L:{ key:"A5_L", label:"A5 quer", w:2480, h:1748 },
};
function paperByKey(key){ return PAPER[key] || PAPER.A4_P; }

const S = {
  cvReady: (window.__cvReady === true),
  warp:{ formatKey:"A4_P" },
  frontImg:null,
  backImg:null,
  pts: { front:[], back:[] },
  view: {
    front:{scale:1, ox:0, oy:0},
    back :{scale:1, ox:0, oy:0},
    grid :{scale:1, ox:0, oy:0}
  },
  pointers:new Map(),
  pinch:null,
  dragPoint:null,
  pan:null,

  work: { front:null, back:null, mode:"none" },
  xRel:[],
  yRel:[],
  disabledCells:new Set(),
  undo:[],

  gridPointers:new Map(),
  gridPinch:null,
  gridPan:null,
  gridLastTap:{t:0, x:0, y:0},
  gridGestureLockUntil:0,
  gridTapTimer: null,
  gridTapCandidate: null,

  cells:[]
};
  window.S = S;


/* ----------------- UI: file pickers ----------------- */
$("btnFrontCam").addEventListener("click", ()=> $("frontCam").click());
$("btnFrontPick").addEventListener("click", ()=> $("frontPick").click());
$("btnBackCam").addEventListener("click", ()=> $("backCam").click());
$("btnBackPick").addEventListener("click", ()=> $("backPick").click());

$("frontCam").addEventListener("change", (e)=> loadSide(e, "front"));
$("frontPick").addEventListener("change", (e)=> loadSide(e, "front"));
$("backCam").addEventListener("change", (e)=> loadSide(e, "back"));
$("backPick").addEventListener("change", (e)=> loadSide(e, "back"));

function updateFrontWarpLabel(){
  const p = paperByKey(S.warp.formatKey);
  $("btnFrontWarp").textContent = `Entzerren (${p.label})`;
}
$("warpFormat").value = S.warp.formatKey;
updateFrontWarpLabel();
$("warpFormat").addEventListener("change", ()=>{
  S.warp.formatKey = $("warpFormat").value;
  updateFrontWarpLabel();
  setStatus(`Format gesetzt: ${paperByKey(S.warp.formatKey).label} (gilt auch f√ºr Back).`);
});

async function loadSide(e, which){
  const f = e.target.files?.[0];
  if(!f) return;
  const imgCanvas = await loadImageFileToCanvas(f);

  S.pts[which]=[];
  S.view[which]={scale:1, ox:0, oy:0};

  if(which==="front"){
    S.frontImg = imgCanvas;
    $("frontState").textContent="geladen";
    $("frontState").className="badge ok";
    $("btnFrontManual").disabled=false;
    $("btnFrontWarp").disabled=true;
    $("btnFrontSkipWarp").disabled=false;
    $("btnFrontResetView").disabled=false;

    $("btnBackCam").disabled=false;
    $("btnBackPick").disabled=false;
    $("backState").textContent="wartet (Back laden)";
    $("backState").className="badge warn";

    hookPhotoCanvas("front");
    renderPhoto("front");
    setStatus("Front geladen.");
  } else {
    S.backImg = imgCanvas;
    $("backState").textContent="geladen";
    $("backState").className="badge ok";
    $("btnBackManual").disabled=false;
    $("btnBackWarp").disabled=true;
    $("btnBackSkipWarp").disabled=false;
    $("btnBackResetView").disabled=false;

    hookPhotoCanvas("back");
    renderPhoto("back");
    setStatus("Back geladen.");
  }
}

/* ----------------- Photo: manual corners + zoom/pan ----------------- */
$("btnFrontManual").addEventListener("click", ()=> startManual("front"));
$("btnBackManual").addEventListener("click", ()=> startManual("back"));
$("btnFrontWarp").addEventListener("click", ()=> warpPaper("front"));
$("btnBackWarp").addEventListener("click", ()=> warpPaper("back"));
$("btnFrontSkipWarp").addEventListener("click", ()=> useRaw("front"));
$("btnBackSkipWarp").addEventListener("click", ()=> useRaw("back"));
$("btnFrontResetView").addEventListener("click", ()=>{ S.view.front={scale:1,ox:0,oy:0}; renderPhoto("front"); });
$("btnBackResetView").addEventListener("click", ()=>{ S.view.back ={scale:1,ox:0,oy:0}; renderPhoto("back"); });

function startManual(which){
  S.pts[which]=[];
  if(which==="front") $("btnFrontWarp").disabled=true;
  else $("btnBackWarp").disabled=true;
  setStatus(`${which.toUpperCase()}: 4√ó tippen (TL‚ÜíTR‚ÜíBR‚ÜíBL).`);
  renderPhoto(which);
}

function hookPhotoCanvas(which){
  const canvas = which==="front" ? $("frontCanvas") : $("backCanvas");
  canvas.onpointerdown = (e)=> photoPointerDown(which, canvas, e);
  canvas.onpointermove = (e)=> photoPointerMove(which, canvas, e);
  canvas.onpointerup   = (e)=> photoPointerUp(which, canvas, e);
  canvas.onpointercancel = (e)=> photoPointerUp(which, canvas, e);
}

function renderPhoto(which){
  const canvas = which==="front" ? $("frontCanvas") : $("backCanvas");
  const img = which==="front" ? S.frontImg : S.backImg;
  const ctx=canvas.getContext("2d");
  ctx.setTransform(1,0,0,1,0,0);
  ctx.clearRect(0,0,canvas.width,canvas.height);
  if(!img) return;

  const baseR = Math.min(canvas.width/img.width, canvas.height/img.height);
  const baseW = img.width*baseR, baseH = img.height*baseR;
  const baseX = (canvas.width-baseW)/2, baseY = (canvas.height-baseH)/2;

  const v=S.view[which];
  ctx.save();
  ctx.translate(baseX+v.ox, baseY+v.oy);
  ctx.scale(v.scale, v.scale);
  ctx.drawImage(img, 0,0, baseW, baseH);
  ctx.restore();

  drawPhotoOverlay(which, {baseR, baseX, baseY});
}

function imgToView(which, pImg, fit){
  const v=S.view[which];
  return {
    x: fit.baseX + v.ox + (pImg.x*fit.baseR)*v.scale,
    y: fit.baseY + v.oy + (pImg.y*fit.baseR)*v.scale
  };
}
function viewToImg(which, pView){
  const canvas = which==="front" ? $("frontCanvas") : $("backCanvas");
  const img = which==="front" ? S.frontImg : S.backImg;

  const baseR = Math.min(canvas.width/img.width, canvas.height/img.height);
  const baseW = img.width*baseR, baseH=img.height*baseR;
  const baseX = (canvas.width-baseW)/2, baseY=(canvas.height-baseH)/2;
  const v=S.view[which];

  const x = (pView.x - (baseX+v.ox)) / v.scale;
  const y = (pView.y - (baseY+v.oy)) / v.scale;

  return {
    x: clamp(x / baseR, 0, img.width-1),
    y: clamp(y / baseR, 0, img.height-1)
  };
}

function drawPhotoOverlay(which, fit){
  const canvas = which==="front" ? $("frontCanvas") : $("backCanvas");
  const ctx=canvas.getContext("2d");
  const pts=S.pts[which];

  ctx.save();
  ctx.lineWidth=4;

  if(pts.length===4){
    ctx.strokeStyle="rgba(0,255,120,.95)";
    ctx.beginPath();
    const p0=imgToView(which, pts[0], fit);
    ctx.moveTo(p0.x,p0.y);
    for(let i=1;i<4;i++){
      const pi=imgToView(which, pts[i], fit);
      ctx.lineTo(pi.x,pi.y);
    }
    ctx.closePath();
    ctx.stroke();
  }

  const R=16;
  for(let i=0;i<pts.length;i++){
    const pv=imgToView(which, pts[i], fit);
    ctx.fillStyle="rgba(0,0,0,.35)";
    ctx.beginPath(); ctx.arc(pv.x,pv.y,R+10,0,Math.PI*2); ctx.fill();
    ctx.fillStyle="rgba(0,255,120,.95)";
    ctx.beginPath(); ctx.arc(pv.x,pv.y,R,0,Math.PI*2); ctx.fill();
    ctx.fillStyle="#000";
    ctx.font="20px -apple-system";
    ctx.fillText(String(i+1), pv.x+R+8, pv.y-8);
  }

  if(pts.length<4){
    ctx.fillStyle="rgba(255,255,255,.95)";
    ctx.font="22px -apple-system";
    ctx.fillText(`Tippe Ecke ${pts.length+1}/4`, 16, 34);
  }
  ctx.restore();
}

function nearestPhotoHandle(which, pView){
  const pts=S.pts[which];
  if(!pts.length) return null;

  const canvas = which==="front" ? $("frontCanvas") : $("backCanvas");
  const img = which==="front" ? S.frontImg : S.backImg;
  const baseR = Math.min(canvas.width/img.width, canvas.height/img.height);
  const baseW = img.width*baseR, baseH=img.height*baseR;
  const baseX = (canvas.width-baseW)/2, baseY=(canvas.height-baseH)/2;
  const fit={baseR, baseX, baseY};

  let best=null;
  for(let i=0;i<pts.length;i++){
    const pv=imgToView(which, pts[i], fit);
    const d=Math.hypot(pv.x-pView.x, pv.y-pView.y);
    if(best===null || d<best.d) best={i,d};
  }
  return (best && best.d<55) ? best.i : null;
}

function photoPointerDown(which, canvas, e){
  canvas.setPointerCapture(e.pointerId);
  const p=localPoint(canvas,e);
  S.pointers.set(e.pointerId, p);

  if(S.pointers.size===2){
    const a=[...S.pointers.values()];
    const d=Math.hypot(a[0].x-a[1].x, a[0].y-a[1].y);
    S.pinch={which, startDist:d, startScale:S.view[which].scale};
    S.dragPoint=null;
    S.pan=null;
    return;
  }

  const hit=nearestPhotoHandle(which, p);
  if(hit!==null){
    S.dragPoint={which, idx:hit};
    return;
  }

  S.pan={which, x:p.x, y:p.y, moved:false, maybeTap:true};
}

function photoPointerMove(which, canvas, e){
  if(!S.pointers.has(e.pointerId)) return;
  const p=localPoint(canvas,e);
  S.pointers.set(e.pointerId, p);

  if(S.pointers.size===2 && S.pinch && S.pinch.which===which){
    const a=[...S.pointers.values()];
    const d=Math.hypot(a[0].x-a[1].x, a[0].y-a[1].y);
    const ratio=d/(S.pinch.startDist||1);
    S.view[which].scale = clampScale(S.pinch.startScale*ratio);
    renderPhoto(which);
    return;
  }

  if(S.dragPoint && S.dragPoint.which===which){
    const pts=S.pts[which];
    pts[S.dragPoint.idx]=viewToImg(which, p);
    renderPhoto(which);
    return;
  }

  if(S.pan && S.pan.which===which){
    const dx=p.x-S.pan.x, dy=p.y-S.pan.y;
    if(Math.hypot(dx,dy)>8){ S.pan.moved=true; S.pan.maybeTap=false; }
    S.view[which].ox += dx;
    S.view[which].oy += dy;
    S.pan.x=p.x; S.pan.y=p.y;
    renderPhoto(which);
  }
}

function photoPointerUp(which, canvas, e){
  const p=localPoint(canvas,e);
  S.pointers.delete(e.pointerId);
  if(S.pointers.size<2) S.pinch=null;

  if(S.pan && S.pan.which===which && S.pan.maybeTap){
    const pts=S.pts[which];
    if(pts.length<4){
      pts.push(viewToImg(which, p));
      renderPhoto(which);
      if(pts.length===4){
        if(which==="front") $("btnFrontWarp").disabled=false;
        else $("btnBackWarp").disabled=false;
        setStatus(`${which.toUpperCase()}: 4 Punkte gesetzt ‚Üí Entzerren m√∂glich.`);
      }
    }
  }

  S.dragPoint=null;
  S.pan=null;
}

/* ----------------- Settings Save/Load ----------------- */
const SETTINGS_IDS = [
  "fmt","jpgq","gridPad","tight",
  "edgeRun","edgeOff",
  "fThrT","fFillT","fThrR","fFillR","fThrB","fFillB","fThrL","fFillL",
  "bThrT","bFillT","bThrR","bFillR","bThrB","bFillB","bThrL","bFillL",
  "tightPad","minRatio","keep",
  "debugOverlay"
];

function settingsGet(){
  const out = { version: 1, ts: Date.now(), values:{} };
  for(const id of SETTINGS_IDS){
    const el = $(id);
    if(!el) continue;
    out.values[id] = (el.type === "checkbox") ? !!el.checked : el.value;
  }
  return out;
}
function settingsApply(obj){
  const v = obj?.values || {};
  for(const id of Object.keys(v)){
    const el = $(id);
    if(!el) continue;
    if(el.type === "checkbox") el.checked = !!v[id];
    else el.value = v[id];
  }
  if($("jpgqLabel") && $("jpgq")) $("jpgqLabel").textContent = $("jpgq").value;
}

$("btnSettingsSave")?.addEventListener("click", ()=>{
  const data = settingsGet();
  downloadBlob(new Blob([JSON.stringify(data,null,2)], {type:"application/json"}), "settings.json");
  setStatus("Einstellungen gespeichert (settings.json).");
});
$("btnSettingsLoad")?.addEventListener("click", ()=> $("settingsLoad")?.click());
$("settingsLoad")?.addEventListener("change", async (e)=>{
  const f = e.target.files?.[0];
  if(!f) return;
  try{
    const obj = JSON.parse(await f.text());
    settingsApply(obj);
    setStatus("Einstellungen geladen.");
  }catch(err){
    console.error(err);
    alert("Konnte settings.json nicht lesen (ung√ºltiges JSON).");
  }finally{
    e.target.value = "";
  }
});

/* ----------------- WORK MODE: raw / warp ----------------- */
function enableGridUI(){
  const readyFront = !!S.work.front;
  const readyBack  = !!S.work.back;

  if(readyFront){
    $("gridState").textContent = readyBack ? "Front+Back ok ‚Üí Grid m√∂glich" : "Front ok ‚Üí Back fehlt";
    $("gridState").className = readyBack ? "badge ok" : "badge warn";

    $("btnUndo").disabled = false;
    $("btnGridResetView").disabled = false;
    $("btnGridClear").disabled = false;
    $("btnGridSave").disabled = false;
    $("btnGridLoad").disabled = false;
    $("btnGridApply").disabled = !readyBack;

    hookGridCanvas();
    renderGrid();
  }else{
    $("gridState").textContent="wartet auf Front";
    $("gridState").className="badge warn";
  }
}

function useRaw(which){
  if(which==="front" && !S.frontImg) return;
  if(which==="back" && !S.backImg) return;

  S.work.mode = "raw";
  if(which==="front"){
    S.work.front = S.frontImg;
    $("frontState").textContent="raw (ohne entzerren)";
    $("frontState").className="badge ok";
  } else {
    S.work.back = S.backImg;
    $("backState").textContent="raw (ohne entzerren)";
    $("backState").className="badge ok";
  }
  enableGridUI();
  setStatus(`${which.toUpperCase()}: weiter ohne Entzerren.`);
}

function canvasToCvSrc(canvasEl){ return cv.imread(canvasEl); }

async function warpPaper(which){
  if(!S.cvReady){
  if(window.__cvReady === false){
    alert("OpenCV.js ist noch nicht bereit oder konnte nicht geladen werden. (Status unten pr√ºfen)");
  }else{
    alert("OpenCV.js ist nicht bereit.");
  }
  return;
}

  const img = which==="front" ? S.frontImg : S.backImg;
  const pts = S.pts[which];
  if(!img || pts.length!==4){
    alert("Bitte 4 Ecken setzen (TL‚ÜíTR‚ÜíBR‚ÜíBL).");
    return;
  }

  const paper = paperByKey(S.warp.formatKey);
  setStatus(`${which.toUpperCase()}: Entzerren l√§uft‚Ä¶ (${paper.label})`);

  try{
    const src = canvasToCvSrc(img);

    const srcTri = cv.matFromArray(4,1,cv.CV_32FC2,[
      pts[0].x, pts[0].y,
      pts[1].x, pts[1].y,
      pts[2].x, pts[2].y,
      pts[3].x, pts[3].y
    ]);
    const W = paper.w, H = paper.h;
    const dstTri = cv.matFromArray(4,1,cv.CV_32FC2,[ 0,0,  W,0,  W,H,  0,H ]);

    const M = cv.getPerspectiveTransform(srcTri, dstTri);
    const dst = new cv.Mat();
    cv.warpPerspective(src, dst, M, new cv.Size(W,H), cv.INTER_LINEAR, cv.BORDER_CONSTANT, new cv.Scalar(255,255,255,255));

    const outCanvas = which==="front" ? $("frontWarpCanvas") : $("backWarpCanvas");
    cv.imshow(outCanvas, dst);

    src.delete(); dst.delete(); M.delete(); srcTri.delete(); dstTri.delete();

    S.work.mode="warp";
    if(which==="front"){
      S.work.front = outCanvas;
      $("frontState").textContent="entzerrt";
      $("frontState").className="badge ok";
    } else {
      S.work.back = outCanvas;
      $("backState").textContent="entzerrt";
      $("backState").className="badge ok";
    }

    enableGridUI();
    setStatus(`${which.toUpperCase()}: entzerrt (${paper.label}).`);
  }catch(err){
    console.error(err);
    alert("Entzerren fehlgeschlagen (siehe Konsole).");
    setStatus("Entzerren fehlgeschlagen.");
  }
}

/* ----------------- Grid ----------------- */
$("btnGridResetView").addEventListener("click", ()=>{ S.view.grid={scale:1,ox:0,oy:0}; renderGrid(); });

$("btnGridClear").addEventListener("click", ()=>{
  S.xRel=[]; S.yRel=[];
  S.disabledCells.clear();
  S.undo=[];
  renderGrid();
  setStatus("Alles gel√∂scht.");
});

$("btnUndo").addEventListener("click", ()=>{
  const a = S.undo.pop();
  if(!a) return;

  if(a.type==="addLine"){
    const arr = a.axis==="x" ? S.xRel : S.yRel;
    const i = arr.findIndex(v=>Math.abs(v-a.value)<1e-9);
    if(i>=0) arr.splice(i,1);
  }else if(a.type==="toggleCell"){
    if(a.toDisabled) S.disabledCells.delete(a.idx);
    else S.disabledCells.add(a.idx);
  }
  renderGrid();
  setStatus("Schritt zur√ºck.");
});

$("btnGridSave").addEventListener("click", ()=>{
  if(!S.work.front) return alert("Erst Front bereit machen.");
  const data = {
    version:2,
    x_rel: [...S.xRel].sort((a,b)=>a-b),
    y_rel: [...S.yRel].sort((a,b)=>a-b),
    disabled: [...S.disabledCells].sort((a,b)=>a-b)
  };
  downloadBlob(new Blob([JSON.stringify(data,null,2)],{type:"application/json"}),"grid.json");
});

$("btnGridLoad").addEventListener("click", ()=> $("gridLoad").click());
$("gridLoad").addEventListener("change", async (e)=>{
  const f=e.target.files?.[0]; if(!f) return;
  const j=JSON.parse(await f.text());
  S.xRel = (j.x_rel||[]).map(Number);
  S.yRel = (j.y_rel||[]).map(Number);
  S.disabledCells = new Set(j.disabled||[]);
  S.undo=[];
  renderGrid();
  setStatus("Grid geladen.");
});

$("gridWhich").addEventListener("change", ()=> renderGrid());

$("btnGridApply").addEventListener("click", ()=>{
  try{
    if(!S.work.front || !S.work.back){
      alert("Front & Back m√ºssen bereit sein (in Step 1/2 'Entzerren' oder 'Ohne Entzerren weiter' klicken).");
      return;
    }
    buildCells();

    const ok = S.cells.length>0;
    $("btnPreview").disabled = !ok;
    $("btnExport").disabled  = !ok;

    $("prevState").textContent = ok ? "bereit" : "wartet";
    $("prevState").className = ok ? "badge ok" : "badge warn";
    $("expState").textContent  = ok ? "bereit" : "wartet";
    $("expState").className  = ok ? "badge ok" : "badge warn";

    setStatus(ok ? `Grid angewandt: ${S.cells.length} Zellen (${S.disabledCells.size} deaktiviert).`
                 : "Grid ergibt keine Zellen (zu wenig Linien?).");
  }catch(err){
    console.error(err);
    alert("Grid anwenden ist abgest√ºrzt. Schau Konsole (F12) ‚Üí Console ‚Üí rote Meldung.");
  }
});

function hookGridCanvas(){
  const c=$("gridCanvas");
  c.onpointerdown = (e)=> gridPointerDown(c,e);
  c.onpointermove = (e)=> gridPointerMove(c,e);
  c.onpointerup   = (e)=> gridPointerUp(c,e);
  c.onpointercancel = (e)=> gridPointerUp(c,e);
}

function gridFitFor(workCanvas){
  const c=$("gridCanvas");
  const iw = workCanvas.width, ih = workCanvas.height;
  const rr0 = Math.min(c.width/iw, c.height/ih);
  const gv=S.view.grid;
  const rr = rr0*gv.scale;
  const w=iw*rr, h=ih*rr;
  const ox=(c.width-w)/2 + gv.ox;
  const oy=(c.height-h)/2 + gv.oy;
  return {rr, ox, oy, w, h, iw, ih};
}

function viewToImgCoord(workCanvas, x, y){
  const {rr, ox, oy, iw, ih} = gridFitFor(workCanvas);
  return { ix:(x-ox)/rr, iy:(y-oy)/rr, iw, ih };
}

function relXtoPx(workCanvas, r){ return Math.round(r * workCanvas.width); }
function relYtoPx(workCanvas, r){ return Math.round(r * workCanvas.height); }

function renderGrid(){
  const c=$("gridCanvas");
  const ctx=c.getContext("2d");
  ctx.setTransform(1,0,0,1,0,0);
  ctx.clearRect(0,0,c.width,c.height);

  const which = $("gridWhich").value;
  const work = which==="front" ? S.work.front : S.work.back;

  if(!work){
    ctx.fillStyle="#111"; ctx.fillRect(0,0,c.width,c.height);
    ctx.fillStyle="#fff"; ctx.font="24px -apple-system";
    ctx.fillText("Erst Front/Back bereit machen.", 20, 50);
    return;
  }

  const fit = gridFitFor(work);
  ctx.drawImage(work, fit.ox, fit.oy, fit.w, fit.h);

  const xs=[0, ...S.xRel.map(r=>relXtoPx(work,r)).sort((a,b)=>a-b), work.width];
  const ys=[0, ...S.yRel.map(r=>relYtoPx(work,r)).sort((a,b)=>a-b), work.height];

  ctx.save();
  ctx.fillStyle="rgba(255,0,0,0.18)";
  let idx=1;
  for(let r=0;r<ys.length-1;r++){
    for(let cc=0;cc<xs.length-1;cc++){
      if(S.disabledCells.has(idx)){
        const x0=xs[cc], x1=xs[cc+1];
        const y0=ys[r],  y1=ys[r+1];
        ctx.fillRect(fit.ox + x0*fit.rr, fit.oy + y0*fit.rr, (x1-x0)*fit.rr, (y1-y0)*fit.rr);
      }
      idx++;
    }
  }
  ctx.restore();

  ctx.save();
  ctx.lineWidth=2;
  ctx.strokeStyle="rgba(0,120,255,0.92)";
  for(const xv of xs){
    const X=fit.ox + xv*fit.rr;
    ctx.beginPath(); ctx.moveTo(X,fit.oy); ctx.lineTo(X,fit.oy+fit.h); ctx.stroke();
  }
  for(const yv of ys){
    const Y=fit.oy + yv*fit.rr;
    ctx.beginPath(); ctx.moveTo(fit.ox,Y); ctx.lineTo(fit.ox+fit.w,Y); ctx.stroke();
  }
  ctx.restore();

  ctx.save();
  ctx.font="78px -apple-system";
  ctx.lineWidth=12;
  ctx.strokeStyle="rgba(0,0,0,0.85)";
  ctx.fillStyle="rgba(0,160,255,0.98)";
  ctx.shadowColor="rgba(0,0,0,0.35)";
  ctx.shadowBlur=8;

  idx=1;
  for(let r=0;r<ys.length-1;r++){
    for(let cc=0;cc<xs.length-1;cc++){
      const tx=fit.ox + xs[cc]*fit.rr + 14;
      const ty=fit.oy + ys[r]*fit.rr + 88;
      ctx.strokeText(String(idx), tx, ty);
      ctx.fillText(String(idx), tx, ty);
      idx++;
    }
  }
  ctx.restore();
}

/* grid interactions */
function gridPointerDown(canvas, e){
  if(!S.work.front) return;
  canvas.setPointerCapture(e.pointerId);
  const p=localPoint(canvas,e);
  S.gridPointers.set(e.pointerId, p);

  if(S.gridPointers.size>=2){
    S.gridGestureLockUntil = Date.now() + 350;
    gridPinchStart();
    return;
  }
  S.gridPan={x:p.x, y:p.y, moved:false};
}

function gridPointerMove(canvas, e){
  if(!S.gridPointers.has(e.pointerId)) return;
  const p=localPoint(canvas,e);
  S.gridPointers.set(e.pointerId, p);

  if(S.gridPointers.size>=2){
    S.gridGestureLockUntil = Date.now() + 350;
    const a=[...S.gridPointers.values()];
    const d=Math.hypot(a[0].x-a[1].x, a[0].y-a[1].y);
    if(!S.gridPinch) gridPinchStart();
    const ratio=d/(S.gridPinch.startDist||1);
    S.view.grid.scale = clampScale(S.gridPinch.startScale*ratio);
    renderGrid();
    return;
  }

  if(S.gridPan){
    const dx=p.x-S.gridPan.x, dy=p.y-S.gridPan.y;
    if(Math.hypot(dx,dy)>10){ S.gridPan.moved=true; S.gridGestureLockUntil = Date.now() + 250; }
    S.view.grid.ox += dx;
    S.view.grid.oy += dy;
    S.gridPan.x=p.x; S.gridPan.y=p.y;
    renderGrid();
  }
}

function gridPointerUp(canvas, e){
  const p = localPoint(canvas,e);
  S.gridPointers.delete(e.pointerId);

  if(S.gridPointers.size < 2) S.gridPinch = null;

  // Wenn gepannt wurde: KEIN Tap (also auch keine Linie, kein Toggle)
  if(S.gridPan && S.gridPan.moved){
    S.gridPan = null;
    return;
  }
  S.gridPan = null;

  // W√§hrend/kurz nach Pinch/Pan: Tap ignorieren
  if(Date.now() < S.gridGestureLockUntil) return;

  const now = Date.now();
  const dt  = now - (S.gridLastTap.t || 0);
  const dd  = Math.hypot(p.x - (S.gridLastTap.x || 0), p.y - (S.gridLastTap.y || 0));

  // Candidate f√ºr m√∂glichen Double-Tap merken
  const isClose = (dt < 320 && dd < 25);

  // Wenn das ein zweiter Tap (DoubleTap) ist:
  if(isClose && S.gridTapCandidate){
    // SingleTap-Linien-Timer killen
    if(S.gridTapTimer){
      clearTimeout(S.gridTapTimer);
      S.gridTapTimer = null;
    }
    S.gridTapCandidate = null;

    const idx = hitTestCell(p.x, p.y);
    if(idx !== null){
      const wasDisabled = S.disabledCells.has(idx);
      if(wasDisabled) S.disabledCells.delete(idx);
      else S.disabledCells.add(idx);

      S.undo.push({type:"toggleCell", idx, toDisabled: !wasDisabled});
      renderGrid();
      setStatus(`Zelle ${idx} ${S.disabledCells.has(idx) ? "deaktiviert" : "aktiviert"}.`);
    }
    S.gridLastTap = {t: now, x: p.x, y: p.y};
    return;
  }

  // Kein DoubleTap: SingleTap NICHT sofort ausf√ºhren,
  // sondern kurz warten ob doch ein zweiter Tap kommt.
  S.gridLastTap = {t: now, x: p.x, y: p.y};
  S.gridTapCandidate = {t: now, x: p.x, y: p.y};

  if(S.gridTapTimer) clearTimeout(S.gridTapTimer);
  S.gridTapTimer = setTimeout(() => {
    // Wenn bis jetzt kein DoubleTap passiert ist -> Linie setzen
    if(S.gridTapCandidate){
      addLineFromTap(S.gridTapCandidate.x, S.gridTapCandidate.y);
      S.gridTapCandidate = null;
    }
    S.gridTapTimer = null;
  }, 320);
}


function gridPinchStart(){
  const a=[...S.gridPointers.values()];
  const d=Math.hypot(a[0].x-a[1].x, a[0].y-a[1].y);
  S.gridPinch={startDist:d, startScale:S.view.grid.scale};
}

function addLineFromTap(x,y){
  const which = $("gridWhich").value;
  const work = which==="front" ? S.work.front : S.work.back;
  if(!work) return;

  const {ix, iy, iw, ih} = viewToImgCoord(work, x, y);
  if(ix<0 || iy<0 || ix>iw || iy>ih) return;

  const mode=$("gridMode").value;
  if(mode==="V"){
    const r = clamp(ix/iw, 0, 1);
    const rr = Math.min(0.999999, Math.max(0.000001, r));
    if(!S.xRel.some(v=>Math.abs(v-rr)<1e-9)){
      S.xRel.push(rr); S.xRel.sort((a,b)=>a-b);
      S.undo.push({type:"addLine", axis:"x", value:rr});
    }
  }else{
    const r = clamp(iy/ih, 0, 1);
    const rr = Math.min(0.999999, Math.max(0.000001, r));
    if(!S.yRel.some(v=>Math.abs(v-rr)<1e-9)){
      S.yRel.push(rr); S.yRel.sort((a,b)=>a-b);
      S.undo.push({type:"addLine", axis:"y", value:rr});
    }
  }
  renderGrid();
}

function hitTestCell(viewX, viewY){
  const which = $("gridWhich").value;
  const work = which==="front" ? S.work.front : S.work.back;
  if(!work) return null;

  const {ix, iy} = viewToImgCoord(work, viewX, viewY);
  if(ix<0 || iy<0 || ix>work.width || iy>work.height) return null;

  const xs=[0, ...S.xRel.map(r=>Math.round(r*work.width)).sort((a,b)=>a-b), work.width];
  const ys=[0, ...S.yRel.map(r=>Math.round(r*work.height)).sort((a,b)=>a-b), work.height];

  let c=-1, r=-1;
  for(let i=0;i<xs.length-1;i++) if(ix>=xs[i] && ix<xs[i+1]){ c=i; break; }
  for(let j=0;j<ys.length-1;j++) if(iy>=ys[j] && iy<ys[j+1]){ r=j; break; }
  if(c<0 || r<0) return null;

  const cols = xs.length-1;
  return r*cols + c + 1;
}

/* ----------------- Cells + preview + export ----------------- */
function buildCells(){
  const pad = parseInt($("gridPad").value||"0",10);
  const workF = S.work.front;
  if(!workF){ S.cells=[]; return; }

  const xs=[0, ...S.xRel.map(r=>Math.round(r*workF.width)).sort((a,b)=>a-b), workF.width];
  const ys=[0, ...S.yRel.map(r=>Math.round(r*workF.height)).sort((a,b)=>a-b), workF.height];

  const cells=[];
  let idx=1;
  for(let r=0;r<ys.length-1;r++){
    for(let c=0;c<xs.length-1;c++){
      let x0=xs[c]+pad, x1=xs[c+1]-pad;
      let y0=ys[r]+pad, y1=ys[r+1]-pad;
      x0=clamp(x0,0,workF.width); x1=clamp(x1,0,workF.width);
      y0=clamp(y0,0,workF.height); y1=clamp(y1,0,workF.height);
      if(x1-x0>5 && y1-y0>5) cells.push({x0,y0,x1,y1, idx});
      idx++;
    }
  }
  S.cells=cells;
}

function cropCanvas(srcCanvas, cell){
  const w=cell.x1-cell.x0, h=cell.y1-cell.y0;
  const c=document.createElement("canvas");
  c.width=w; c.height=h;
  c.getContext("2d").drawImage(srcCanvas, cell.x0,cell.y0,w,h, 0,0,w,h);
  return c;
}

function val(id, def){
  const el = $(id);
  return el ? el.value : def;
}

/*
  FIX #1: Symmetrie darf NICHT max werden (f√ºhrt zu Vollbild),
          sondern: minimaler symmetrischer Rand (plus mini extra),
          und NICHT nachtr√§glich verschieben -> sonst wird‚Äôs wieder ‚Äúgro√ü‚Äù.
*/
function tightOrFull(cellCanvas, which){
  if(!$("tight").checked) return cellCanvas;

  const pad      = parseInt(val("tightPad", "0"), 10);
  const minRatio = parseFloat(val("minRatio", "0.005"));
  const keep     = parseFloat(val("keep", "0.05"));

  const needConsec = clamp(parseInt(val("edgeRun","2"),10), 1, 12);
  const edgeOff    = clamp(parseInt(val("edgeOff","6"),10), 0, 200);

  const pref = (which==="back") ? "b" : "f";
  const thrT = clamp(parseInt(val(`${pref}ThrT`,"35"),10), 1, 255);
  const thrR = clamp(parseInt(val(`${pref}ThrR`,"35"),10), 1, 255);
  const thrB = clamp(parseInt(val(`${pref}ThrB`,"35"),10), 1, 255);
  const thrL = clamp(parseInt(val(`${pref}ThrL`,"35"),10), 1, 255);

  const fillT = clamp(parseFloat(val(`${pref}FillT`,"0.02")), 0.0005, 0.8);
  const fillR = clamp(parseFloat(val(`${pref}FillR`,"0.02")), 0.0005, 0.8);
  const fillB = clamp(parseFloat(val(`${pref}FillB`,"0.02")), 0.0005, 0.8);
  const fillL = clamp(parseFloat(val(`${pref}FillL`,"0.02")), 0.0005, 0.8);

  const w = cellCanvas.width, h = cellCanvas.height;
  if(w<10 || h<10) return cellCanvas;

  const MAX_SCAN = 900;
  const scale = Math.min(1, MAX_SCAN / Math.max(w,h));
  const sw = Math.max(1, Math.round(w*scale));
  const sh = Math.max(1, Math.round(h*scale));

  const sc = document.createElement("canvas");
  sc.width = sw; sc.height = sh;
  const sctx = sc.getContext("2d", {willReadFrequently:true});
  sctx.drawImage(cellCanvas, 0,0, w,h, 0,0, sw,sh);

  let img;
  try{
    img = sctx.getImageData(0,0,sw,sh);
  }catch(e){
    console.warn("tight getImageData blocked, fallback to full cell", e);
    return cellCanvas;
  }
  const d = img.data;

  const band = Math.min(2, Math.max(1, Math.floor(Math.min(sw,sh)/200)));
  let sr=0, sg=0, sb=0, n=0;
  function addPixel(i){ sr+=d[i]; sg+=d[i+1]; sb+=d[i+2]; n++; }
  for(let y=0;y<sh;y++){
    for(let x=0;x<sw;x++){
      const onBorder = (x<band || x>=sw-band || y<band || y>=sh-band);
      if(!onBorder) continue;
      addPixel((y*sw + x)*4);
    }
  }
  if(n<10) return cellCanvas;
  const bgR = sr/n, bgG = sg/n, bgB = sb/n;

  function scoreAt(i){
    const dr = Math.abs(d[i]-bgR);
    const dg = Math.abs(d[i+1]-bgG);
    const db = Math.abs(d[i+2]-bgB);
    return Math.min(255, (dr+dg+db)/3);
  }

  let fg=0;
  const thrMin = Math.min(thrT,thrR,thrB,thrL);
  for(let i=0;i<d.length;i+=4){
    if(scoreAt(i) > thrMin) fg++;
  }
  const ratio = fg / (sw*sh);
  if(ratio < minRatio) return cellCanvas;

  function rowFgFrac(y, thr){
    let c=0; const off=y*sw*4;
    for(let x=0;x<sw;x++){
      if(scoreAt(off + x*4) > thr) c++;
    }
    return c / sw;
  }
  function colFgFrac(x, thr){
    let c=0;
    for(let y=0;y<sh;y++){
      if(scoreAt((y*sw + x)*4) > thr) c++;
    }
    return c / sh;
  }

  function findTop(){
    let consec=0;
    for(let y=edgeOff;y<sh;y++){
      if(rowFgFrac(y, thrT) >= fillT) consec++; else consec=0;
      if(consec>=needConsec) return Math.max(0, y-(needConsec-1));
    }
    return null;
  }
  function findBottom(){
    let consec=0;
    for(let y=sh-1-edgeOff;y>=0;y--){
      if(rowFgFrac(y, thrB) >= fillB) consec++; else consec=0;
      if(consec>=needConsec) return Math.min(sh-1, y+(needConsec-1));
    }
    return null;
  }
  function findLeft(){
    let consec=0;
    for(let x=edgeOff;x<sw;x++){
      if(colFgFrac(x, thrL) >= fillL) consec++; else consec=0;
      if(consec>=needConsec) return Math.max(0, x-(needConsec-1));
    }
    return null;
  }
  function findRight(){
    let consec=0;
    for(let x=sw-1-edgeOff;x>=0;x--){
      if(colFgFrac(x, thrR) >= fillR) consec++; else consec=0;
      if(consec>=needConsec) return Math.min(sw-1, x+(needConsec-1));
    }
    return null;
  }

  let top = findTop();
  let bottom = findBottom();
  let left = findLeft();
  let right = findRight();

  if(top===null || bottom===null || left===null || right===null) return cellCanvas;
  if(right-left < 5 || bottom-top < 5) return cellCanvas;

  const padS = Math.round(pad * scale);
  left   = clamp(left   - padS, 0, sw-1);
  right  = clamp(right  + padS, 0, sw-1);
  top    = clamp(top    - padS, 0, sh-1);
  bottom = clamp(bottom + padS, 0, sh-1);

  const cwS = right-left+1, chS = bottom-top+1;
  if((cwS/sw)<keep || (chS/sh)<keep) return cellCanvas;

  // ===== FIX #1: MINIMAL SYMMETRIC (statt maximal) =====
  const padL = left;
  const padR = (sw-1-right);
  const padT = top;
  const padB = (sh-1-bottom);

  const maxSym = Math.min(padL, padR, padT, padB);   // wieviel symmetrisch m√∂glich w√§re
  const tiny = Math.round(2*scale);                  // kleiner Extra-Abstand
  const symPad = clamp(tiny, 0, maxSym);             // NICHT maxSym nehmen!

  let nL = left  - symPad;
  let nR = right + symPad;
  let nT = top   - symPad;
  let nB = bottom+ symPad;

  nL = clamp(nL, 0, sw-1);
  nR = clamp(nR, 0, sw-1);
  nT = clamp(nT, 0, sh-1);
  nB = clamp(nB, 0, sh-1);

  if((nR-nL+1) < 6 || (nB-nT+1) < 6){
    nL = left; nR = right; nT = top; nB = bottom;
  }

  const x0 = Math.floor(nL / scale);
  const y0 = Math.floor(nT / scale);
  const x1 = Math.ceil((nR+1) / scale);
  const y1 = Math.ceil((nB+1) / scale);

  const X0 = clamp(x0, 0, w-1);
  const Y0 = clamp(y0, 0, h-1);
  const X1 = clamp(x1, 1, w);
  const Y1 = clamp(y1, 1, h);

  const outW = X1 - X0;
  const outH = Y1 - Y0;
  if(outW<6 || outH<6) return cellCanvas;

  const out = document.createElement("canvas");
  out.width = outW;
  out.height = outH;
  out.getContext("2d").drawImage(cellCanvas, X0,Y0,outW,outH, 0,0,outW,outH);

  const dbg = {
    sw, sh,
    scale,                 // wichtig f√ºrs Overlay!
    detected: { left, right, top, bottom },
    final: { left:nL, right:nR, top:nT, bottom:nB }
  };

  cellCanvas.__dbg = dbg; // f√ºrs Zeichnen auf voller Zelle
  out.__dbg = dbg;        // optional f√ºrs Pair debug
  return out;
}

/* ===== FIX #4: Debug Overlay korrekt umrechnen (scan -> full) ===== */
function drawFitTo(canvas, src){
  const ctx = canvas.getContext("2d");
  ctx.setTransform(1,0,0,1,0,0);
  ctx.clearRect(0,0,canvas.width,canvas.height);

  const r = Math.min(canvas.width/src.width, canvas.height/src.height);
  const w = src.width * r;
  const h = src.height * r;
  const x = (canvas.width  - w) / 2;
  const y = (canvas.height - h) / 2;

  ctx.drawImage(src, x, y, w, h);

  drawDebugOverlay(canvas, src, {r,x,y});
}

function drawDebugOverlay(canvas, src, fit){
  const dbg = src?.__dbg;
  if(!dbg) return;
  const chk = $("debugOverlay");
  if(!chk || !chk.checked) return;

  const ctx = canvas.getContext("2d");
  const inv = 1 / (dbg.scale || 1); // scan->full

  function toCanvasRect(rect){
    const x0 = (rect.left  * inv) * fit.r + fit.x;
    const y0 = (rect.top   * inv) * fit.r + fit.y;
    const x1 = (rect.right * inv) * fit.r + fit.x;
    const y1 = (rect.bottom* inv) * fit.r + fit.y;
    return {x0,y0,w:(x1-x0),h:(y1-y0)};
  }

  const det = toCanvasRect({left:dbg.detected.left, right:dbg.detected.right, top:dbg.detected.top, bottom:dbg.detected.bottom});
  const fin = toCanvasRect({left:dbg.final.left, right:dbg.final.right, top:dbg.final.top, bottom:dbg.final.bottom});

  ctx.save();
  ctx.lineWidth = 3;

  ctx.strokeStyle = "rgba(0,200,0,0.9)";
  ctx.strokeRect(det.x0, det.y0, det.w, det.h);

  ctx.strokeStyle = "rgba(220,0,0,0.9)";
  ctx.strokeRect(fin.x0, fin.y0, fin.w, fin.h);

  ctx.restore();
}

function buildPairCanvas(front, back){
  const pair=document.createElement("canvas");
  pair.width = front.width + back.width;
  pair.height = Math.max(front.height, back.height);
  const pctx=pair.getContext("2d");
  pctx.fillStyle="#fff"; pctx.fillRect(0,0,pair.width,pair.height);
  pctx.drawImage(front,0,0);
  pctx.drawImage(back,front.width,0);
  return pair;
}

/* ===== FIX #2: Preview zeigt volle Zelle + Overlay; Pair zeigt crop ===== */
$("btnPreview").addEventListener("click", ()=>{
  if(!S.work.front || !S.work.back) return alert("Front & Back m√ºssen bereit sein (entzerrt oder raw).");
  buildCells();
  if(!S.cells.length) return alert("Grid ergibt keine Zellen.");

  const idx = clamp(parseInt($("idx").value||"1",10), 1, S.cells.length);
  $("idx").value = idx;
  const cell = S.cells[idx-1];

  const f0 = cropCanvas(S.work.front, cell);
  const b0 = cropCanvas(S.work.back, cell);

  // erzeugt dbg auf f0/b0 und crop-canvas f√ºr Pair
  let f = tightOrFull(f0, "front");
  let b = tightOrFull(b0, "back");

  if(!f || f.width < 10 || f.height < 10) f = f0;
  if(!b || b.width < 10 || b.height < 10) b = b0;

  // Front/Back: volle Zelle
  drawFitTo($("knobFront"), f0);
  drawFitTo($("knobBack"), b0);

  // Pair: gecroppt
  const doPairs = $("pairs").checked;
  $("pairLabel").style.display = doPairs ? "block" : "none";
  $("knobPair").style.display  = doPairs ? "block" : "none";
  if(doPairs){
    drawFitTo($("knobPair"), buildPairCanvas(f,b));
  }
});

/* Export */
async function canvasToBlob(c, fmt, q){
  return await new Promise(res=>{
    if(fmt==="png") c.toBlob(res,"image/png");
    else c.toBlob(res,"image/jpeg", q);
  });
}

$("btnExport").addEventListener("click", async ()=>{
  if(!S.work.front || !S.work.back) return alert("Front & Back m√ºssen bereit sein (entzerrt oder raw).");
  buildCells();
  if(!S.cells.length) return alert("Grid ergibt keine Zellen.");

  const fmt=$("fmt").value;
  const q=parseInt($("jpgq").value,10)/100;
  const doPairs=$("pairs").checked;

  const zip=new JSZip();
  const F=zip.folder("front");
  const B=zip.folder("back");
  const P=doPairs ? zip.folder("pairs") : null;

  setStatus("Export l√§uft‚Ä¶");

  let exported=0;
  for(const cell of S.cells){
    if(S.disabledCells.has(cell.idx)) continue;

    const f0 = cropCanvas(S.work.front, cell);
    const b0 = cropCanvas(S.work.back, cell);

    let f = tightOrFull(f0, "front");
    let b = tightOrFull(b0, "back");

    if(!f || f.width < 10 || f.height < 10) f = f0;
    if(!b || b.width < 10 || b.height < 10) b = b0;

    F.file(`front_${pad3(cell.idx)}.${fmt}`, await canvasToBlob(f, fmt, q));
    B.file(`back_${pad3(cell.idx)}.${fmt}`,  await canvasToBlob(b, fmt, q));

    if(doPairs){
      const pair = buildPairCanvas(f,b);
      P.file(`pair_${pad3(cell.idx)}.jpg`, await canvasToBlob(pair, "jpg", q));
    }

    exported++;
    if(exported % 5 === 0) setStatus(`Export‚Ä¶ ${exported} Zellen‚Ä¶`);
  }

  const outBlob = await zip.generateAsync({type:"blob"});
  downloadBlob(outBlob, "buttongridtool_export.zip");
  setStatus(`Fertig. Exportiert: ${exported} Zellen (deaktiviert: ${S.disabledCells.size}).`);
});

/* Startstatus */
setStatus("OpenCV.js l√§dt‚Ä¶");
</script>
</body>
</html>
